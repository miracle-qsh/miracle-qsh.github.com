{"meta":{"title":"QSH's blog","subtitle":"","description":"心如花木，向阳而生","author":"QSH","url":"http://miracle-qsh.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-03-07T09:52:50.566Z","updated":"2020-03-07T09:52:50.566Z","comments":true,"path":"categories/index.html","permalink":"http://miracle-qsh.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-07T09:53:33.191Z","updated":"2020-03-07T09:53:33.191Z","comments":true,"path":"tags/index.html","permalink":"http://miracle-qsh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"春招面试总结","slug":"春招总结","date":"2020-04-21T10:02:43.822Z","updated":"2020-04-21T10:05:19.037Z","comments":true,"path":"2020/04/21/春招总结/","link":"","permalink":"http://miracle-qsh.github.io/2020/04/21/%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/","excerpt":"总结从二月份以来所经历的面试情况","text":"总结从二月份以来所经历的面试情况 春招面试情况字节跳动 Rust/C++研发实习：二面技术面试挂 基础架构研发实习：三面技术面试+HR面，已完成 阿里巴巴 支付宝JAVA研发实习：笔试+四面技术面试+HR面试，已offer 腾讯 音乐人JAVA实习：二面技术面试挂 微信技术架构实习：两面技术面试+HR面试，已offer 美团点评 到店餐饮JAVA实习：笔试+两面技术面试+HR面试，已完成 三七互娱 Web后端实习：笔试+两面技术面试+HR面试，已完成 百度 C++/PHP研发实习：笔试+三面技术面试，等待HR面试中 快手 基础架构实习：笔试+两面技术面试，等待HR面试中 吉比特 游戏研发实习：笔试+一面面试，已挂 网易 游戏研发实习：笔试已通过，等约面中 面经整理字节跳动Rust/C++研发实习一面 从输入一个url到浏览器响应的过程中经历的了什么？ 说一下TCP三次握手的过程？ TCP的拥塞控制有哪些机制？ 说一下HTTP握手的过程？ 说一下HTTP1.0和HTTP1.1的区别？ 说一下HTTP和HTTPS的区别？ 说一下短连接和长连接的区别？ 说一下什么是HTTP流水线机制？ 进程和线程的区别？ 进程间通信的方式有哪些？ 线程间通信的方式有哪些？ 说一下悲观锁和乐观锁的区别？ 算法题：最大字段和问题？ 算法题：每一次可以修改某个数的一位，求把素数A修改到素数B的方案数？ 二面 算法题：K个有序数组归并？ 算法题：将一个整数划分为不同数字之和的方案数？ 讲一下智能指针？ Extern C的作用？ Std：：move的作用？ 数据库索引的作用？ 讲一下联合索引的原理？ 说一下linux的innode机制？ 说一下页溢出和段溢出？ 说一下TCP和UDP的区别？ 说一下TCP的拥塞控制机制？ 相邻两次进入拥塞避免状态的时间之差是多少？ cookie和session的区别？ 基础架构实习一面 说一下TCP三次握手状态机图？ 说一下SYN攻击？ 说一下四次挥手状态机图？ 说一下TIME_WAIT的作用？ 如果没有TIME_WAIT会发生什么？ 发送方不停恶意发起TCP连接请求该怎么解决？ 说一下程序运行过程的状态机图？ 说一下进程间通信方式？ 什么是孤儿进程？ 什么是僵尸进程？ 如何解决僵尸进程？ linux如何查看内存使用情况 算法题：一个先增后降的数组排序 二面 说一下网络分层 有TCP了为什么还要HTTP 为什么要分层 HTTP相比于TCP有什么不同 C++unorder_map底层实现是什么 哈希表如何解决冲突 冲突太多怎么解决 哈希表扩容为什么要倍增 多线程有哪些实现方式 Atomic的作用 Atomic的底层实现 说一下CAS的实现 算法题：树的直径 三面 算法题：单链表快排 TOP K问题 多线程实现同步的技术了解哪些 进程通信的技术有哪些 说一下TCP三次握手、四次挥手 阿里巴巴支付宝JAVA研发实习一面 链表判断有环 链表判断有环并返回环的入口 链表判断有环并返回环的入口，不允许开额外空间 两个链表判断相交，返回交点 两个链表判断相交，返回交点，不允许开额外空间 两个栈模拟队列 两个栈模拟队列，实现最小栈 两个队列模拟一个栈 网络分层，每层作用 三次握手 四次挥手 为什么要三次握手，两次可不可以 为什么要四次挥手，三次可不可以 如果两次握手会发生什么 TCP拥塞控制机制 详细解释慢开始、拥塞避免、快重传、快恢复 滑动窗口的作用 进程和线程的区别 线程和协程的区别 进程间通信的方法 socket通信的过程 银行家算法 页面置换算法有哪些，详细说说 数据库事务的特性 如何保证原子性 你了解哪些锁 事务的隔离级别 不可重复读解决什么问题 不可重复读能解决幻读吗 什么是幻读 设计一个微信红包算法 二面 实现一个IDE IDE如何实现代码格式规范化 实现一个支付通信接口 如果公钥更换了怎么办 如果频繁更换怎么办 如果一个用户恶意访问接口怎么办 接口功能不能停的情况下，新旧公钥如何过渡 实现一个微博推送功能 如果博主反复更新动态怎么办 实现一个搜索引擎 三面 聊价值观、方法论 四面 谈一下对面向对象程序设计的看法 了解过哪些设计模式 说一下对网络分层的看法 为什么要分层 有IP协议了，为什么还需要TCP/UDP协议 对加密算法了解哪些 了解过中间件吗 看过哪些开源项目的源码 腾讯音乐人JAVA实习一面 介绍一下虚拟内存 介绍一下银行家算法 进程间通信方式 线程间通信方式 说一下网络分层 TCP三次握手 滑动窗口的作用 栈和队列的特点及应用场景 什么是幻读 怎么解决幻读 介绍一下死锁的产生条件 有哪些解决死锁的办法 二面 介绍一下进程间通信方式 TCP三次握手的过程 为什么要三次握手 TCP四次挥手的过程 进程和线程的区别 谈谈对ioc容器的看法 数据库事务的隔离级别 微信技术架构实习一面 算法题：实现一个memcopy函数 算法题：归并两个有序链表 算法题：实现一个抽奖函数（rand6实现均等概率的rand30） 场景题：一百万个数取前100大的数字 场景题：200G的文本文件，每个字符串不超过16字节，100M内存，取前100个的高频字符串 二面 算法题：链表去重 算法题：找出合法的IP地址 算法题：判断两个多项式是否等价 算法题：按出现频率排序 算法题：多个活动给出开始时间和结束时间，求最少需要多少会议室才能全部安排 场景题：设计一个服务器 美团点评到店餐饮JAVA实习一面 Static关键字的作用 Const的作用 虚函数的具体实现 纯虚函数和虚函数的区别 Static变量的初始化时间 介绍一下智能指针 TCP三次握手 TCP四次挥手 进程和线程的区别 Linux命令了解哪些 智力题：蚂蚁爬杆问题 二面 JAVA和C++的区别 谈谈对面向对象的看法 Hash_map的实现原理 哈希表处理冲突的方法 哈希表的扩容为什么要倍增 哈希表的平均插入复杂度是多少，怎么证明 三七互娱Web后端实习一面 面向对象的特点 谈谈你理解的多态 进程线程的区别 进程间通信的方式有哪些 介绍一下虚拟内存 数据库事务的隔离级别 不可重复读解决什么问题 什么是脏读 什么是幻读 单例模式的懒汉式如何实现 TCP三次握手过程 TCP四次挥手过程 二面 聊价值观、谈理想 百度C++/PHP研发实习一面 Const关键字的作用 介绍一下智能指针 循环引用如何解决 说一下虚函数的实现机制 B+树和红黑树的区别 为什么使用B+树作为数据库索引的数据结构 AVL树和红黑树的区别 说一下AVL树具体如何旋转 算法题：链表判环 算法题：链表判环并返回环开始的位置 二面 算法题：一个颜色数组，求包含所有颜色的最小连续字段长度 算法题：一个环形颜色数组，求包含所有颜色的最小连续字段长度 场景题：TOPK问题 介绍一下KMP算法 介绍一下AC自动机算法 三面 纳什博弈 概率题：不均等概率硬币实现均等概率 如果让你设计百度搜索的广告推送，你会怎样设计 快手基础架构实习一面 Static作用 内存分区 编译过程 实现一个分享式智能指针 算法题：链表分组反转 算法题：活动安排 二面 算法题：实现O（N）排序 编译过程 实现代码文件去除注释功能 TOPK问题 文件字符串去重 吉比特游戏研发实习一面 介绍一下智能指针 引用和指针的区别 介绍一下右值引用 最小生成树算法 并查集 智力题：元旦不是星期二问题 进程与线程的区别 进程通信方式 TCP三次握手过程 TCP四次挥手过程 复习资料整理 计算机基础+算法：https://cyc2018.github.io/CS-Notes/#/README 计算机基础：https://github.com/wolverinn/Waking-Up 后端面试重点难点：https://xiaozhuanlan.com/topic/2167809435 个人博客：https://miracle-qsh.github.io/ 简历制作 超级简历：https://www.wondercv.com/cvs","categories":[{"name":"春招","slug":"春招","permalink":"http://miracle-qsh.github.io/categories/%E6%98%A5%E6%8B%9B/"}],"tags":[{"name":"春招","slug":"春招","permalink":"http://miracle-qsh.github.io/tags/%E6%98%A5%E6%8B%9B/"}]},{"title":"Socket","slug":"socket","date":"2020-03-09T02:13:38.381Z","updated":"2020-04-08T00:48:54.542Z","comments":true,"path":"2020/03/09/socket/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/09/socket/","excerpt":"Socket的总结，结合常见问题","text":"Socket的总结，结合常见问题 介绍一下I/O模型一个输入操作，包含：等待数据准备好，从内核向进程复制数据两个阶段 五大I/O模型阻塞时I/O、非阻塞式I/O、I/O复用、信号驱动式I/O、异步I/O 介绍一下阻塞式I/O应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回 介绍一下非阻塞式I/O应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling） 阻塞式I/O与非阻塞式I/O的区别阻塞式I/O发起后进程会被阻塞，非阻塞式I/O不会，但阻塞式I/O没有那么多的系统调用，CPU利用率高 介绍一下I/O复用使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中，它可以让单个进程具有处理多个 I/O 事件的能力 介绍一下信号驱动I/O应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中 介绍一下异步I/O应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号 异步I/O与信号驱动I/O的区别异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O 介绍一下select使用fd_set实现，大小为FD_SETSIZE，三种描述符类型readset、writeset、exceptset timeout为超时参数 成功返回大于0，出错为-1，超时为0 介绍一下poll与select类似，描述符为pollfd类型数组 select与poll的比较select会修改描述符，poll不会 select有数量限制，poll没有 poll对描述符的重复利用比select高 select可移植性比poll高 介绍一下epollepoll_creat()创建句柄，声明监听的数目+1 epoll_ctl()用于添加/删除/修改描述符（维护在红黑树上） epoll_wait()轮询I/O事件的发生 epoll不会产生select/poll的监听某描述符时另一线程关闭该描述符造成的不确定结果 介绍一下epoll的两种工作模式LT模式：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking ET模式：和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://miracle-qsh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://miracle-qsh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"SQL","slug":"SQL","date":"2020-03-09T02:10:41.183Z","updated":"2020-04-08T00:49:05.645Z","comments":true,"path":"2020/03/09/SQL/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/09/SQL/","excerpt":"SQL的总结，结合常见问题","text":"SQL的总结，结合常见问题 数据库的创建与使用1create database test;2use test; 创建表1create table mytable(2 id int not null auto_increment,3 col1 int not null default 1,4 col2 varchar(45) null,5 col3 date null,6 primary key(id)7); 修改表1alter table mytable2add col char(20);3alter table mytable4drop column col;5drop table mytable; 插入1insert into mytable(cols, col2)2values(val1, val2); 1insert into mytable1(col1, col2)2select col1, col23from mytable2; 1create table newtable as2select * from mytable; 更新1update mytable2set col = val3where id = 1; 删除1delete from mytable2where id = 1; 1truncate table mytable; 查询distinct1select distinct col1, col22from mytable; limit1select *2from mytable3limit 5;4select *5from mytable6limit 0, 5; 1select *2from mytable3limit 2, 3;4# 3-5行 排序 ASC升序 DESC降序 1select *2from mytable3order by col1 desc, col2 asc; 过滤1select *2from mytable3where col is null; 操作符 说明 = 等于 &lt; 小于 &gt; 大于 &lt;&gt; != 不等于 &lt;= !&gt; 小于等于 &gt;= !&lt; 大于等于 BETWEEN 在两个值之间 IS NULL 为 NULL 值 AND 和 OR 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。 IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。 NOT 操作符用于否定一个条件 通配符 % 匹配 &gt;=0 个任意字符； _ 匹配 ==1 个任意字符； [ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。 1select *2from mytable3where col like '[^AB]%'; 计算字段1select col1 * col2 as alias2from mytable; CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。 1SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_col2FROM mytable;Copy to clipboardErrorCopied 函数汇总 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 1SELECT AVG(DISTINCT col1) AS avg_col2FROM mytable; 文本处理 函数 说明 LEFT() 左边的字符 RIGHT() 右边的字符 LOWER() 转换为小写字符 UPPER() 转换为大写字符 LTRIM() 去除左边的空格 RTRIM() 去除右边的空格 LENGTH() 长度 SOUNDEX() 转换为语音值 1SELECT *2FROM mytable3WHERE SOUNDEX(col1) = SOUNDEX('apple')Copy to clipboardErrorCopied 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:MM:SS 函 数 说 明 ADDDATE() 增加一个日期（天、周等） ADDTIME() 增加一个时间（时、分等） CURDATE() 返回当前日期 CURTIME() 返回当前时间 DATE() 返回日期时间的日期部分 DATEDIFF() 计算两个日期之差 DATE_ADD() 高度灵活的日期运算函数 DATE_FORMAT() 返回一个格式化的日期或时间串 DAY() 返回一个日期的天数部分 DAYOFWEEK() 对于一个日期，返回对应的星期几 HOUR() 返回一个时间的小时部分 MINUTE() 返回一个时间的分钟部分 MONTH() 返回一个日期的月份部分 NOW() 返回当前日期和时间 SECOND() 返回一个时间的秒部分 TIME() 返回一个日期时间的时间部分 YEAR() 返回一个日期的年份部分 1mysql&gt; SELECT NOW();2# 2018-4-14 20:25:11 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 分组1select col, count(*) as num2from mytable3group by col4order by num; WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。 1SELECT col, COUNT(*) AS num2FROM mytable3WHERE col &gt; 24GROUP BY col5HAVING num &gt;= 2; 分组规定： GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。 子查询1select *2from mytable13where col1 in (select col24 from mytable2); 连接内连接1select a.value, b.value2from tablea as a inner join tableb as b3on a.key = b.key; 1select a.value, b.value2from tablea as a, tableb as b3where a.key = b.key; 自连接1select e1.name2from employee as e1 inner join employee as e23on e1.val = e2.val4and e2.name = \"jim\"; 自然连接自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。 内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。 1select a.val, b.val2from tablea as a natural join tableb as b; 外连接外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。 检索所有顾客的订单信息，包括还没有订单信息的顾客。 1SELECT Customers.cust_id, Orders.order_num2FROM Customers LEFT OUTER JOIN Orders3ON Customers.cust_id = Orders.cust_id; customers 表： cust_id cust_name 1 a 2 b 3 c orders 表： order_id cust_id 1 1 2 1 3 3 4 3 结果： cust_id cust_name order_id 1 a 1 1 a 2 3 c 3 3 c 4 2 b Null 组合查询1select col2from mytable3where col = 14union5select col6from mytable7where col = 2;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MySQL","slug":"MySQL","date":"2020-03-08T13:32:12.168Z","updated":"2020-04-08T00:48:49.337Z","comments":true,"path":"2020/03/08/MySQL/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/08/MySQL/","excerpt":"MySQL的总结，结合常见问题","text":"MySQL的总结，结合常见问题 索引B+ Tree原理数据结构B Tree是平衡树，是一颗查找树，所有叶子节点位于同一层 B+ Tree基于B Tree和叶子节点顺序访问指针实现，具有平衡性，通过顺序访问指针提高区间查询性能 B+ Tree中，一个节点中的key从左到右非递减排列 操作查找操作时，首先在根节点进行二分查找，找到一个key所在的指针，然后递归的在指针所指向的节点进行查找，知道找到叶子节点，然后再叶子节点上进行二分查找，找到key对应的data 插入删除操作会破坏平衡树的平衡性，因此在插入删除操作后，需要对树进行一个分裂、合并、旋转等操作维护平衡性 与红黑树的比较红黑树等平衡性也可以用来实现索引，但文件系统和数据库普遍采用B+树作为索引结构，原因有二： 更少的查找次数 利用磁盘预读特性 MySQL索引索引在存储引擎层实现 B+ Tree索引大多数MySQL存储引擎默认索引类型 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。 因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。 可以指定多个列作为索引列，多个索引列共同组成键。 适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。 InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。 哈希索引哈希索引能以 O(1) 时间进行查找，但是失去了有序性： 无法用于排序与分组； 只支持精确查找，无法用于部分查找和范围查找。 InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 全文索引MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。 InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。 空间数据索引MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。 必须使用 GIS 相关的函数来维护数据。 索引优化独立的列在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 例如下面的查询不能使用 actor_id 列的索引： 1SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 多列索引在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。 1SELECT film_id, actor_ id FROM sakila.film_actor2WHERE actor_id = 1 AND film_id = 1; 索引列顺序让选择性最强的索引列放在前面。 索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。 例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 1SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,2COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,3COUNT(*)4FROM payment;Copy to clipboardErrorCopied5 staff_id_selectivity: 0.00016customer_id_selectivity: 0.03737 COUNT(*): 16049 前缀索引对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 前缀长度的选取需要根据索引选择性来确定。 覆盖索引索引包含所有需要查询的字段的值。 具有以下优点： 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。 索引的优点 大大减少了服务器需要扫描的数据行数。 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起） 索引的使用条件 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效； 对于中到大型的表，索引就非常有效； 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 查询性能优化使用Explain分析优化数据访问减少请求的数据量 只返回必要的列：最好不要使用 SELECT * 语句。 只返回必要的行：使用 LIMIT 语句来限制返回的数据。 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。 减少服务端扫描的行数使用索引 重构查询方式切分大查询分解大连接查询存储引擎InnoDB是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。 实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。 MyISAM设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。 提供了大量的特性，包括压缩表、空间数据索引等。 不支持事务。 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。 比较 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。 外键：InnoDB 支持外键。 备份：InnoDB 支持在线热备份。 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 其它特性：MyISAM 支持压缩表和空间数据索引。 数据类型整型、浮点数、字符串、时间和日期（datatime日期、timestamp格里尼治秒数） 切分水平切分水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。 当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。 垂直切分垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。 在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。 参考资料CS-Notes","categories":[{"name":"数据库","slug":"数据库","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"http://miracle-qsh.github.io/tags/MySQL/"}]},{"title":"C++总结(3)","slug":"C++3","date":"2020-03-08T11:47:00.048Z","updated":"2020-04-08T00:48:31.407Z","comments":true,"path":"2020/03/08/C++3/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/08/C++3/","excerpt":"C++第三次总结，结合常见问题","text":"C++第三次总结，结合常见问题 sizeof和strlen区别 strlen计算字符串的具体长度，不包括字符串结束符，返回字符个数 sizeof计算什么后站的内存数（字节大小），不是实际长度 strlen是一个函数，sizeof是一个取字节的运算符 sizeof的返回值是字符个数*字符所占的字节数，字符实际长度小于定义的长度 sizeof可以用类型做参数，strlen只能用char*做参数，且只能用‘\\0’结尾 数组做sizeof的参数不退化，传递给strlen就退化成指针 简述strcpy、sprintf、memcpy区别 操作对象不同 strcpy的两个操作对象均为字符串 sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串 memcpy的两个操作对象就是两个任意可操作的内存地址 执行效率不同 memcpy最高，strcpy次之，sprintf最差 实现功能不同 strcpy主要实现字符串变量间的拷贝 sprintf主要实现其他数据类型到字符串的转化 memcpy主要是内存块间的拷贝 编码实现某变量某位清零1#define BIT3 (0x1 &lt;&lt; 3)2void set_bit3(void)&#123;3 a |= BIT3;4&#125;5void set_bit3(void)&#123;6 a &amp;= ~BIT3;7&#125; 将引用作为函数参数有哪些特点 传递引用给函数与传递指针给函数效果是一样的 使用引用做参数，并没有在内存中产生实参副本，是直接对实参操作；而一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。 使用指针作为函数参数虽然也能达到一样的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用*变量名的形式进行运算；另外，在主调函数处必须使用变量的地址做实参 分别写出bool，int，flost，指针类型的变量a与零的比较1bool: if(!a) or if(a)2int: if(a == 0)3float: const EXPRESSION EXP = 0.000014if(a &lt; EXP &amp;&amp; a &gt; -EXP)5pointer: if(a != NULL) or if(a == NULL) 局部变量全局变量的问题 局部会屏蔽全局。要用全局变量，需要使用“：：”，局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量 如何引用一个已经定义过的全局变量，可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引入某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用，假定你犯了同样错误，会在链接期间报错 全局变量定义在不同C文件中，需要以static形式来声明 数组和指针的区别 数组在内存中时连续存放的，开辟一块连续的内存空间；数组作所占的空间：sizeof（数组名）；数组大小：sizeof（数组名）/sizeof（元素类型） 用运算符sizeof可以计算数组大小，sizeof（指针）得到的是指针变量的大小，而不是指向内存的大小 向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针 数组原地址固定，指针不固定 C++如何组织一个类被实例化？一般在什么时候将构造函数声明为private？ 将类定义为抽象基类或者将构造函数声明为private 不允许类外部创建类对象，只能在类内部创建对象 如何禁止自动生成拷贝构造函数 为了组织编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要将他们设置为private，防止被调用 类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，会产生一个连接错误 针对上述两种情况，我们可以定义一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置为private，那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关操作 assert与NDEBUGE assert宏的原型定义在&lt;assert.h&gt;，其作用是如果它的条件返回错误，则终止程序执行，原型定义： 1#include &lt;assert.h&gt;2void assert(int expression); assert的作用是先计算表达式expression，如果其值为假，那么它先向stderr打印一条出错信息，然后通过调用abort来终止程序运行 NDBEBUGE宏是Standard C中定义的宏，专门用来控制assert()的行为。如果定义了这个宏，则assert不会起作用 main函数有没有返回值 程序运行过程入口点，main函数，返回值必须是int，这样返回值才能传递给程序激活者表示程序正常退出。main(int args, int char **args) 参数传递，参数处理一般会调用getopt()函数处理 写一个比较大小的模板函数1#include &lt;ioatream&gt;2using namespace std;3template&lt;typename type1, typename type2&gt;4type1 Max(type1 a, type2 b)5&#123;6 return a &gt; b ? a : b;7&#125; C++怎么实现一个函数先于main函数运行 如果在main函数之前声明一个类的全局变量的对象，那么执行顺序先于main函数 定义在main函数之前的全局对象、静态对象的构造函数在main函数之前执行 mian函数执行之前，主要是初始化系统相关资源 设置栈指针 初始化static静态和global全局变量，即data段的内容 将未初始化部分的全局变量赋初值，即bss段内容 全局对象初始化，在main之前调用构造函数 将main函数的参数，argc，argv等传递给main函数，然后才开始执行main函数 main函数执行之后 全局对象的析构函数会在main函数之后执行 可以用_onexit注册一个函数，它会在main之后执行 虚函数和纯虚函数的区别在于 纯虚函数只有定义没有实现，虚函数既有定义又有实现 含有传虚函数的类不能定义对象，含有虚函数的类可以定义对象 智能指针怎么用，只能指针出现循环引用怎么解决 shar_ptr调用一个名为make_shared的标准库函数，每个shared_ptr都有一个关联计数器，通常称为引用计数，一旦一个shared_ptr的计数器变为零，他就会自动释放自己所管理的对象；shared_ptr的析构函数就会递减它所指向的对象的引用计数。如果引用计数变为零，shared_ptr的析构函数就会销毁对象，并释放它占用的内存 unique_ptr，某一时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁 weak_ptr,是一种不控制所指向对象生存期的智能指针，他指向一个由shared_ptr管理的对象，将一个weak_ptr绑定到一个shared_ptr不会改变引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象还是会被释放 弱指针用于专门解决循环引用问题 strcpy和strncpy函数的区别，那个函数更安全 函数原型 char * strcpy(char *strDest, const char * strSrc) char * strncpy(char *strDet, const char *strSrc, int pos) strcpy函数：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误 strncpy函数：用来复制源字符串的前n个字符，src和dest所指的内存区域不能重叠，且dest必须有足够长的空间放置n个字符 如果目标长&gt;指定长&gt;源长,则源长全部拷贝到目标长，自动加上‘\\0’ 如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\\0’ 如果指定长&gt;目标长，运行错误 为什么要用static_cast转换而不用c语言中的转换 更加安全 更清楚直接，可读性好 成员函数里memset(this, 0, sizeof(*this))会发生什么 有时候类里面定义了很多int，char，struct等c语言里哪些类型的变量，该函数可以将整个对象的内存全部置为零 类中含有虚函数时，会破坏虚函数表 类中含有C++类型的对象时，会破坏对象的内存 回调函数的作用 当发生某事件时，系统或其他函数将会自动调用你定义的一段函数 回调函数就相当于一个中断处理函数，有系统在符合你设定的条件时自动调用。为此，你需要做三件事情：声明、定义、设置触发条件，就是在你的函数中吧你的回调函数名称转化为地址作为一个参数，以便系统调用 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需要知道的，只是存在一个具有某种特定原型、某些限制条件的被调用函数 随机数的生成 #include &lt;time.h&gt; srand(unsigned)time(NULL); 为什么拷贝构造函数必须传引用不能传值 拷贝构造函数的作用就是用来赋值对象的，在使用这个对象的实例来初始化这个对象的一个新实例 参数传递的过程到底发生了什么 将地址传递和值传递统一起来，归根结底还是传递的是值（地址也是指，只不过可以通过它找到另一个值） 值传递：对于内置数据类型的传递时，直接赋值拷贝给形参；对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参（局部对象）；如void foo(class_type obj_local){}，如果调用foo(obj)；首先class_type obj_local(obj)，这样就定义了局部变量obj_local供函数内部使用 引用传递：无论内置类型还是类类型，传递引用或指针最终都是传递地址值，而地址总是指针类型，显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用 拷贝构造函数用值传递会产生无限递归调用，内存溢出 空类的大小是多少？为什么 C++空类的大小不为零，不同编译器设置不一样，vs设置为1； C++标准指出，不允许一个对象的大小为0，不同对象不能具有相同地址 带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定 C++中要求对于类的每个实例都必须有杜伊五二的地址，那么编译器自动为空类分配一个字节大小，这样保证了每个实例均有独一无二的内存地址 大内存申请的时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？ 大内存申请时，采用堆申请空间，用new申请 不同变量存在不同的地方，局部变量、全局变量、静态变量 C++对变量名不做存储，在汇编以后不会出现变量名，变量名作用只是用于方便编译成汇编代码，是给编译器看的，是方便人阅读的 静态函数能定义为虚函数吗？常函数？ static成员不属于任何类对象或类实例，所以即使给此函数加上virtual也是没有任何意义的 static函数中没有this指针 常函数可以 那些函数不能作为虚函数 普通函数、友元函数、静态函数、构造函数、拷贝构造函数 this调用成员变量时，堆栈会发生什么变化 当类的非静态成员函数访问类的非静态成员时，把编译器会自动将对象的地址作为隐函数参数传递给函数，这个隐含参数就是this指针。即使你并没有写this指针，编译器在连接时也会加上this，对各成员的访问都是通过this的。this指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈 静态绑定和动态绑定的介绍 对象的静态类型：对象在声明时采用的类型。在编译器确定 对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，静态类型无法更改 静态绑定：当定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译器 动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期 设计一个类计算子类的个数 为类设计一个static变量count作为计数器 类定义结束后初始化count 在构造函数中对count+1 设计拷贝构造函数，在进行拷贝构造函数中count+1 在赋值构造函数中count+1 在析构函数中count-1 虚函数的代价 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚函数成员的指针，增大类 带有虚函数的类发每一个对象，都会有一个指向虚表的指针，会增加对象的空间的大小 不能内联 类对象的大小 类的非静态成员变量大小，静态成员不占类的空间，成员函数也不占据类的空间大小 内存对齐另外分配的空间大小，类的数据也是需要进行内存对齐操作的 虚函数的话，会在类对象插入vptr指针 如果该类是某类的派生类，那么派生类继承基类部分数据成员也会存在派生类的空间中 移动构造函数 有时我们会遇到这种情况，我们用对象a初始化对象b后对象a我们就不再使用了，但是对象a的空间还在，既然拷贝函数实际上就是把a对象的内容复制一份给b，那么为什么不能直接使用a的空间呢，因此有了移动构造函数 拷贝构造函数，对于指针，我们一定要采用深层复制，而在移动构造函数中，对于指针，我们采用浅复制 C++引入了移动构造函数，专门处理这种，用a初始化b后就将a析构的情况 与拷贝类似，移动也是使用一个对象的值设置另一个对象的值。但是又与拷贝不同的是，移动实现的是对象值真实的转移；源对象丢失其内容，被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象是时候（典型的就是函数返回值或类型转换返回值）。使用临时对象的值初始化另一个对象的值，不会要求对对象的复制，因为临时对象不会有其他使用，因而，它的值可以被移动到目的对象。 何时需要合成构造函数 如果一个类没有任何构造函数，但他有一个成员对象，该成员对象含有默认构造函数，那么编译器就会为该类合成一个默认构造函数。 没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该类合成一个构造函数 带有虚函数的类 带有一个虚基类的类 何时需要合成复制构造函数 对一个对象做显示的初始化操作 对象被当作参数交给某函数时 函数传回一个类对象时 如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型有拷贝构造函数 如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类 如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数 如果一个类没有拷贝构造函数，但是该类含有虚基类 何时需要成员初始化列表 初始化一个引用成员变量时 初始化一个const成员变量时 调用一个基类构造函数，而构造函数拥有一组参数时 调用一个成员类的构造函数，而构造函数有一组参数 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前 程序员定义的析构函数被扩展的过程 析构函数函数体被执行 如果class 拥有成员类对象，而后者拥有析构函数，那么它们会以声明顺序的相反顺序被调用 如果对象有一个vptr，限制被重新定义 如果有任何直接的上一层非虚基类拥有析构函数，则它们会有声明顺序被调用 如果任何虚基类拥有析构函数 构造函数的执行算法 虚基类及基类构造函数 vptr初始化 成员初始化列表 程序员提供的代码 迭代器++it，it++哪个好，为什么 前置返回一个引用，后置返回一个对象 ++i实现代码为： 1iknt &amp; operator++()&#123;2 *this += 1;3 return *this;4&#125; 前置不会产生临时对象，后置必须产生临时对象 i++实现代码为： 1int operator++(int)&#123;2 int temp = *this;3 ++*this;4 return temp;5&#125; C++如何处理多个异常 C++中的异常情况 语法错误、运行错误 C++异常处理机制 异常处理基本思想：执行一个函数过程中发生异常，可以不用在本函数立即进行处理，而是抛出异常，让函数的调用者直接或间接处理这个问题 C++异常处理机制由3个模块组成：try、throw、catch 抛出异常的语句个数为throw表达式；如果try快中程序段发生了异常则抛出异常 1try&#123;23&#125;4catch()&#123;56&#125;7catch()&#123;89&#125; 模板和实现可不可以不写在一个文件里面？为什么 因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的cpp文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的cpp文件的存在，所以他只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于连接程序找地址。但模板类或函数的实现并不能被编译成二进制代码，结果连接程序找不到地址只好报错 模板定义很特殊，由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为他分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一种机制能去掉制定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？ 在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他函数的调用只要不涉及this指针的内容，都可以正常执行。一旦涉及this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题 delete this之后释放了类对象的内存空间，那么这段内存已经还给了系统，不再属于这个进程。照这个逻辑看应该发生指针错误，无访问权限之类的问题，但实际不是这样，内存空间并不是马上被挥手给系统，可能是缓冲或者其他什么原因，导致这段内存空间暂时没有被系统收回。此时这段内存是可以访问的，你可以操作他，但其中的值确实不确定的 如果在类的析构函数中调用delete this，会发生什么？ 会导致堆栈溢出，因为delete里调用析构函数并释放内存，会形成无限递归 auto_ptr作用 auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄露”的问题；抛出异常，将异常导致指针p所指向的空间得不到释放而导致内存泄漏 auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏 auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象 由于auto_ptr对象析构时会删除它所拥有的指针，作用使用时避免多个auto_ptr对象管理同一个指针 auto_ptr内部实现，析构函数中删除对象用的时delete而不是delete[]，所以auto不能管理数组 auto_ptr支持所拥有的指针类型之间的隐式类型转换 class、union、struct的区别 c语言中struct只是一个聚合数据类型，没有权限设置，无法添加成员函数，无法实现面向对象编程，且如果没有 typedef结构名，声明结构变量必须添加关键字struct C++中struct功能大大扩展，可以有权限设置，可以有成员函数，继承，可以实现面向对象编程，允许声明时省略关键字strut union：一种数据格式，能够存储不同数据类型，但只能同时存储其中的一种。C++中union时一种特殊的类，可以有访问权限，成员变量，成员函数，不能包含虚函数和静态数据，不能继承和派生 动态联编和静态联编 在C++中，联编是指一个计算机程序的不同部分彼此关联的过程，按照联编所进行的阶段不同，可以分为静态联编和动态联编 静态联编是指联编工作在编译阶段完成，这种联编过程是在程序运行之前完成的，又称为早期联编。要实现静态联编，在编译阶段就必须确认程序中的操作调用与执行该操作代码间的关系，确定这种关系成为束定，在编译时的束定成为静态束定。静态联编对函数的选择基于指向对象或者引用的类型。其优点是效率高，但灵活性差 动态联编是指联编在程序运行时动态的进行，根据当时的情况来确定调用哪个同名函数，实际上时在运行时虚函数的实现。这种联编又称为晚期联编，或动态束定。动态联编对成员函数的选择时经济与对象的类型，针对不同的对象类型做出不同的编译结果 动态编译与静态编译 静态编译，编译器在编译可执行文件时，需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库 动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态连接库的命令。所以其优点一方面时缩小了执行文件文件本身的体积，另一方面加快了编译速度，节省了系统资源。缺点是哪怕很简单的程序，只用到连接库的一两条命令，也需要附带一个相对庞大的连接库；二是如果其他计算机上没有安装对应的运行库，则动态编译的可执行文件不能运行 动态链接和静态链接区别 静态链接库就是把（lib）文件中用到的函数到目直接连接进目标程序，程序运行期间不需要其他库文件；动态链接时把调用的函数所在文件模块（dll）和调用函数在文件中的位置等信息连接进目标程序，程序运行的时候再从dll中寻找相应函数代码，因此需要相应dll文件支持 静态连接库与动态连接库都是共享代码的方式，如果采用静态连接库，无论你愿不愿意，lib中的指令都全部被直接包含在最终exe文件中，但若是使用dll，改dll不必被包含着最终exe文件中，exe文件执行时可以“动态”的引用和卸载这个与exe独立的dll文件。静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他静态库或动态链接库，动态链接库可以 动态链接库就是在需要调用其中函数的时候，根据函数映射表找到该函数然后调入堆栈执行。如果当前工程中有多处对dll文件中同意函数的调用，那么执行时，这个函数只会留下一份拷贝。但lib会留下多份拷贝 vloatile关键字的作用 用它声明的类型变量表示可以被某些编译器未知因素修改 空类会默认添加哪些东西 缺省构造函数 拷贝构造函数 析构函数 赋值运算符 new、delete、operator new、operator delete、placement new、placementdelete new 申请内存和初始化对象 operator new 只申请内存 placement new用于在给定内存中初始化对象 宏定义一个取两个数较大值的功能 #define MAX(x,y) ((x&gt;y)?x:y) define、const、typedef、inline使用方法 const、define区别 const定义的常量是变量带类型，define只是常熟不带类型 define在预处理阶段起作用，const在编译连接过程起作用 define没有类型检查、const有 define占代码段，const占数据段 const不能重定义，define可以取消，然后重定义 define独特功能，可以防止文件重复引用 define和别名typedef的区别 执行时间不同，typedef在编译阶段，有类型检查，define在预处理阶段，没有类型检查 功能差异，typedef结合struct使用，define功能更多 define没有作用域限制，typedef有自己的作用域 inline和define区别 define是预处理阶段，inline是编译阶段 inline函数有类型检查，更安全 printf实现原理 在C++中函数参数的扫描时从后往前的，通过压入堆栈的方式来给函数传参数，数据有两块，一块是堆，一块是栈，栈是从内存高地址向内存低地址生长的，控制生长的就是堆栈指针，最先压入的参数在最上面，所以最后压入的参数总能被函数找到。printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可以算出数据需要的堆栈指针的偏移量 include的顺序及尖括号和双引号的区别 表示编译器只在系统默认目录或尖括号内的工作目录下搜索 表示现在用户工作目录下找头文件，找不到去系统默认目录下找 helloworld程序开始到打印到屏幕上的全过程 开始 操作系统找到程序相关信息，检查是否是可执行文件，并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址 创建新进程，将程序可执行文件映射到该进程结构中 为程序设置cpu上下文环境，跳转到程序开始处 执行命令，发生缺页中断 分配一页物理内存，将代码从磁盘读入内存，继续执行程序 程序执行puts函数，在显示器上写一字符串 找到显示设备，将字符串送给管理设备的进程 设备的窗口系统确认是合法操作，将字符串转换成像素，写入存储映像区 解释信号 模板类和模板函数区别 函数模板的实例化时由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显示地指定。 为什么模板类一般都是放在一个h文件中 模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。 在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来，所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。 C++中访问权限和继承权限 public、private、protected cout和printf区别 cout&lt;&lt;是一个函数，有缓冲输出 printf没有缓冲输出，立即输出 重载运算符 我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数； ：： ？： sizeof typeid **不能重载； 两种重载方式，成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符； 引入运算符重载，是为了实现类的多态性； 当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数； 从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）； 下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本； 箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针； 重载函数匹配原则 名字查找 确定候选 寻找最佳 定义和声明的区别 如果是指变量的什么和定义，声明只是告诉编译器某个类型的变量会被使用，定义是指分配了内存 函数的声明和定义，声明不需要实现，定义需要实现 C++类型转换 static_cast 能进行基础类型之间的转换，也是最长看到的类型转换。它主要有如下几种用法： 用于类层次结构中父类和子类之间指针或引用的转换。进行上行转换是安全的 进行下行转换时，没有动态类型检查，是不安全的 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum，安全性需要开发人员保证 把void指针转成目标指针（不安全） 把其他指针转成void指针 const_cast去除指向常熟对象的指针或引用的常量性 reinterpret_cast可以把指针转换成一个证书，或把证书转换成一个指针 dynamic_cast主要用在继承体系中的安全向下转型，会用运行时信息（RTTI）来进行类型安全性检查，必须包含虚函数（通过使用vtable中的信息来判断实际类型） 全局变量和static变量区别 全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。 static函数与普通函数有什么区别？static函数与普通的函数作用域不同。尽在本文件中。只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。 static函数与普通函数最主要区别是static函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆） 静态成员与普通成员的区别 生命周期 静态成员变量从类被加载开始到类被卸载，一直存在； 普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束； 共享方式 静态成员变量是全类共享；普通成员变量是每个对象单独享用的； 定义位置 普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区； 初始化位置 普通成员变量在类中初始化；静态成员变量在类外初始化； 默认实参 可以使用静态成员变量作为默认实参 ifdef、endif 满足条件时编译 隐式转换 C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换 C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。 基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。 C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。 如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。","categories":[{"name":"C++","slug":"C","permalink":"http://miracle-qsh.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://miracle-qsh.github.io/tags/C/"}]},{"title":"C++总结(2)","slug":"C++2","date":"2020-03-08T11:45:31.050Z","updated":"2020-04-08T00:48:26.478Z","comments":true,"path":"2020/03/08/C++2/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/08/C++2/","excerpt":"C++第二次总结，结合常见问题","text":"C++第二次总结，结合常见问题 内存相关C++程序内存分区 栈区：函数中定义的局部变量 堆区：动态分配的内存空间 全局区：全局变量、静态数据、常量 常量区：常量字符串 代码区：代码二进制码 存储在全局区的变量什么时候进行初始化 C语言中程序开始运行时即完成初始化 C++中初始化发生在执行相关代码之前 C++中是否可以使用变量初始化静态局部变量 只要变量的定义在静态局部变量执行之前即可 什么时浅复制与深复制 浅复制：只是拷贝基本类型数据，而引用类型数据复制后仍指向原引用对象 深复制：在计算机中开辟新内存地址存放复制对象 浅复制会带来什么问题 动态分配内存的变量A浅复制给变量B，则析构时会发生两次释放内存，出现运行错误 C中的struct与C++中的struct有什么区别 C中struct是用户自定义数据类型；C++中的struct是抽象数据类型，支持成员函数、继承、多态 C中struct没有权限设置；C++中有权限控制 C中定义struct变量时要加上struct；C++不用 关键字相关static的作用 隐藏：修饰的函数与变量仅当前文件可见 持久：修饰的变量生存期到程序结束 初始化：修饰的变量默认初始化为0 公用：类中被修饰的变量和函数被该类所有对象共有 static修饰的成员函数（类中）能否使用this指针 不能使用，因为static修饰的成员函数被所有对象共有，且可通过类名::直接调用，故不能使用this指针 类内使用static有什么要注意的 static修饰的类对象必须在类外进行初始化 static修饰的成员函数不能访问非static成员变量 static修饰的成员函数不能被virtual修饰 为什么static类对象必须在类外初始化 static修饰的变量在相关代码开始运行时即初始化，先于对象存在，因此需要类外初始化 如果不初始化会报连接错误 为什么static成员函数不能访问非static成员变量 C++访问成员变量的方法是通过this指针，但static函数没有this指针，因此不能访问非static成员函数 为什么static成员函数不能被virtual修饰 虚函数的实现是为每一个对象分配一个vptr指针，指向虚函数表，而vptr是通过this指针调用的，static函数没有this指针，故不能被virtual修饰 const的作用 修饰变量：修饰的变量不可被改变 修饰指针：可指定指针或指针指向的数据不可改变 修饰引用：修饰的引用所指的对象不可改变 修饰参数：修饰的变量在函数内部不可改变 修饰成员函数：修饰函数不可改变成员变量 类的常对象可以访问类的非常成员函数吗 不能，任何没被const修饰的成员函数被认为会修改类的成员变量 非const成员函数可以访问const对象的数据成员吗 不能，任何没被const修饰的成员函数被认为会修改类的成员变量 const成员函数可以访问非const对象的数据成员吗 可以访问，因为const成员函数只是不能修改成员变量，并非不能访问成员变量 使用const关键字需要注意些什么 const变量定义时必须初始化 const修饰指针的几种情况 指针不可变：int * const p; 指针指向的值不可变：int const *p; 指针与指针指向的值均不可变：int const * const p; extern的作用 引入外部变量/函数：修饰的变量会自动去别的文件查找 指示调用C/C++库函数：extern &quot;C&quot;声明函数为C函数 有全局变量了为什么还要用extern 如果不同文件共同include同一个文件，则被引用文件中的变量定义会重复，使用extern可以只声明而不定义。 inline的作用 内联函数，提高效率 内联函数的原理 在编译期间，对调用内联函数的地方的代码替换成函数代码 类相关构造函数与析构函数的作用 构造函数起初始化值的作用，会在对象实例化时自动调用 析构函数用于撤销对象的操作，无参数，无返回值，不能重载，一个类只有一个析构函数，对象销毁时会自动调用析构函数 类成员初始化的方式有哪些 赋值初始化：会产生临时对象 初始化列表 赋值初始化和列表初始化有什么区别 赋值初始化在所有数据成员被分配内存空间后才进行 列表初始化在给数据成员分配内存空间时即进行 为什么列表初始化比赋值初始化要快一些 对于内置类型，不会调用构造函数，因此列表初始化与赋值初始化性能相同 对于类类型，因为在进入函数体之前，所有对象已构造完成，列表初始化在进入函数体之前，因此只需要构造一次，而赋值初始化在进入函数体之后进行，需要在进行一次赋值操作，会产生临时对象，进行拷贝构造 构造函数的执行顺序 虚基类构造函数 基类构造函数 类类型成员对象构造函数 派生类自己的构造函数 解释一下什么是虚基类 虚基类是为了防止重复继承而出现的机制，比如A继承于B和C，B和C均继承与D，那么A就会继承两份D的成员变量，将D声明为虚基类后，A只会继承一份 必须使用成员列表初始化的情况有哪些 初始化引用成员时，因为引用不可以被赋值 初始化常量成员时，因为常量不可以被赋值 基类构造函数有参数时，因为没有默认构造函数，无法空参构造 成员类构造函数有参数时，因为没有默认构造函数，无法空参构造 构造函数为什么不能是虚函数 虚函数是通过vptr指针实现指向虚函数表的，如果构造函数是虚函数，那么必须调用vptr指针，但此时对象还没实例化，昔找不到vptr，也就无法运行 基类析构函数为什么要是虚函数 为了防止内存泄漏，因为如果基类析构函数不是虚函数，那么如果派生类中申请了内存空间，并且通过基类指针指向的派生类删除时，只会调用基类的析构函数，派生类申请的空间无法释放 构造函数和析构函数中可以调用虚函数吗 可以，但不提倡，构造函数和析构函数中调用虚函数，使用的是该类中定义的虚函数，不会进行动态联编，如果子类中没有定义虚函数但构造函数中调用了它，会报错 虚函数的调用关系 this -&gt; vptr -&gt; ctable -&gt; virtual function 虚函数可以声明为inline吗 不能，虚因为函数在运行时进行类型确定，而内联函数在编译时完成函数替代 泛型相关C++模板的底层实现 编译器对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译 模板为什么要经过两次编译 模板函数要被是李丽华之后才能成为真正的函数，如果只进行一次编译，那么若是引入的头文件中只有声明，没有定义，那么编译器无法实例化，造成连接错误","categories":[{"name":"C++","slug":"C","permalink":"http://miracle-qsh.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://miracle-qsh.github.io/tags/C/"}]},{"title":"C++总结(1)","slug":"C++1","date":"2020-03-08T11:43:05.433Z","updated":"2020-04-08T00:48:22.955Z","comments":true,"path":"2020/03/08/C++1/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/08/C++1/","excerpt":"C++第一次总结，结合常见问题","text":"C++第一次总结，结合常见问题 const作用修饰变量，修饰指针，修饰引用，修饰成员函数 const与#define的区别const带类型，define不带类型 const在编译和运行时起作用，define在预处理阶段起作用 define没有类型检查，const有类型检查 define占代码段空间，const占数据段空间 static作用修饰全局变量，修饰局部变量，修饰普通函数，修饰成员函数 介绍一下this指针指向对象本身的指针 介绍一下inline内联函数相当于把函数体写在调用函数处，类中函数（除虚函数）隐式为内联函数，有类型检查，提高了效率，但导致了代码膨胀 虚函数可以内联吗可以内联，但表现多态时不行 volatile关键字作用使修饰的变量不会被优化 assert()作用如果它的条件返回错误，终止程序执行 sizeof()作用获得变量或数组的大小，sizeof(指针)为指针大小 pragma pack(n)作用以n字节方式内存对齐 extern作用引用另一个文件中的变量或函数 struct和typedef struct区别struct是定义结构体类型 typedef struct是为结构体类型设置别名 什么是函数指针指向函数的指针，和指针变量一样，通过指针访问调用函数 struct 和 class区别默认访问控制不同 struct是public，class是private union特点默认访问控制public 可以有构造函数、析构函数 不能有引用 不能继承派生 不能有虚函数 同一时间只有一个变量有值 struct和union的区别union可以有构造函数和析构函数，struct没有 union不能有引用，struct可以 union不能有虚函数，struct可以 union同一时间只有一个变量有值 explicit关键字的作用声明类构造函数是显示调用的 介绍一下友元friend修饰，之后可以访问友元类的私有成语和函数 using的作用引入命名空间 ::运算符的作用范围解析（全局、类、命名空间） 介绍一下enum类型枚举类型 介绍一下引用左值引用，右值引用（右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值） 指针和引用的区别指针是一个变量，引用是一个别名 引用的大小是被引用对象的大小，指针大小是指针变量本身的大小 引用必须初始化，指针不用 引用不可修改，指针能修改 引用底层是指针实现的 介绍一下宏#define，一对一的替换 介绍一下虚函数用virtual关键字修饰，可以实现，也可以不实现（纯虚函数），存在纯虚函数的类叫抽象类，全部为纯虚函数的类叫接口类，用来实现多态，可以在子类中重新定义 什么是是虚析构函数虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象 什么是纯虚函数纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做 虚函数与纯虚函数的区别虚函数有具体实现，纯虚函数只是声明 介绍一下虚函数指针在含有虚函数类的对象中，指向虚函数表，在运行时确定 介绍一下虚函数表在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原基类的那个虚函数指针 介绍一下C++的内存分配和管理malloc：申请指定字节数的内存。申请到的内存中的初始值不确定 calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0 realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定 alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca malloc和free的底层实现先搜索堆中的空闲链表，如果有合适大小，直接分配，否则就向系统重新申请一段内存，用完后标记为空闲状态 C++数组越界会发生什么数组越界会发生覆盖原有的数据，如果比较重要，可能会崩溃，如果不重要，肯就没有明显影响 介绍一下智能指针用来实现内存的自动回收 智能指针是如何实现的RAII技术（资源获取即初始化） 介绍一下shared_ptrshared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同内存，每使用一次，计数加一，析构一次计数减一，减为零时删除指向的堆内存 要注意不能用原始指针初始化多个shared_ptr 避免循环引用 介绍一下weak_ptr为了配合shared_ptr引入的，不具有普通指针行为，可以观测资源使用情况，use_count()观测引用计数，lock()获得shared_ptr对象 什么是循环引用两个shared_ptr相互引用 如何解决循环引用将一个改为weak_ptr auto的用法auto x = …； delete this合法吗合法 delete this应用场景this对象必须是通过new（不是new[]）分配出来的；必须保证调用delete this的函数是最后一个调用this的函数，delete this 之后不能在使用this；不能delete this多次 new和delete底层实现new 是调用operator new函数申请空间（malloc），在申请空间上执行构造函数构造对象 delete是在空间上执行析构函数清理对象资源，调用operator delete函数释放空间 malloc/free和new/delete的区别malloc/free是C的库函数，new/delete是C++的运算符，new/delete底层用malloc和free实现，malloc不能自动的调用构造函数和析构函数 介绍一下模板模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 通过模板就可以实现定义不同类型的结构和函数 介绍一下常见的STL及用法参考 huihut STL总结 传送链接 STL迭代器什么时候会失效进行插入删除操作时，影响到的迭代器会失效","categories":[{"name":"C++","slug":"C","permalink":"http://miracle-qsh.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://miracle-qsh.github.io/tags/C/"}]},{"title":"操作系统原理","slug":"操作系统原理","date":"2020-03-08T11:40:36.900Z","updated":"2020-04-08T00:47:31.936Z","comments":true,"path":"2020/03/08/操作系统原理/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/","excerpt":"操作系统原理的总结，结合常见问题","text":"操作系统原理的总结，结合常见问题 什么是中断中断是指计算机运行过程中出现意外情况干预，机器暂停正在运行的程序，转入新程序，处理完后返回被暂停的程序继续执行 中断的分类外中断（IO），异常，陷入（系统调用） 什么是用户态只能受限的访问内存，且不允许访问外围设备，占有CPU的能力被剥夺，CPU资源可以被其他程序获取 什么是内核态CPU可以访问内存所有数据，包括外围设备 为什么要有用户态和内核态需要限制不同程序之间的访问能力 如何从用户态进入内核态系统调用、中断、异常 介绍一下缓存通过将最近使用的资源存储到缓存中，实现资源的快速读取 什么是缓存溢出超出常规长度的字符填满一个域 介绍一下进程与线程的区别以及使用场景进程是资源调度的基本单位，线程是独立运行的基本单位 进程有资源，线程没有 进程开销大，线程开销小 线程可以直接读取同一进程的数据，进程通信需要IPC 需要安全稳定时用进程，等待慢速IO时交给线程，接着做其他事情 进程状态有哪些执行状态，阻塞状态，就绪状态 进程调度算法的特点先来先服务（FCFS）短作业优先（SJF）最短剩余时间优先（SRTF）时间片轮转，优先级调度，多级反馈队列，重要进程立刻响应 线程的实现方式C++11引入，通过std::thread obj(函数指针/函数对象)实现多线程 介绍一下协程协程比线程更轻量，本质是单线程，一个线程可以拥有多个协程 协程的作用协程不被操作系统内核管理，完全由程序控制（用户态），开销远小于线程 协程的缺点本质是单线程，进行阻塞操作时会阻塞整个程序 进程同步的机制临界区、同步与互斥、信号量、管程 信号与信号量的区别信号是处理进程间异步通信的 信号量是处理同步通信的 生产者-消费者实现队列不满时生产者可投放，队列不为空时消费者可取出 读者写者实现允许多进程同时读，但不允许读和写，写和写同时发生 哲学家进餐实现五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子 必须同时拿起左右两根筷子，两个邻居都不进餐时才可进餐 进程通信的方式及特点、应用场景管道（父子，半双工），命名管道（去除父子限制），消息队列（避免同步阻塞问题，有选择接收），信号量，共享存储，套接字 死锁的必要条件互斥、占有等待、不可抢占、环路等待 解决死锁的策死锁检查与回复，死锁预防，死锁避免 什么是虚拟内存让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存 虚拟内存的作用扩充内存 虚拟内存的实现分页系统+页面置换算法 页面置换算法原理最佳（OPT，最长时间未使用），LRU（最近最久未使用）时钟（clock） 什么是分页管理将地址空间分成固定大小的页，每一页与内存映射 什么是分段管理分段，每段一个独立地址空间，段长可变 介绍一下段页式分段，每一段分页 分页与分段的区别分页透明，分段需要显示划分段的大小 分页是一维地址，分段是二维地址 页的大小不可变，段的大小可变 分页是为了实现虚拟内存，分段是为了是程序和数据逻辑上独立 静态链接的不足动态链接的特点向操作系统申请4G连续空间能分配吗不能，正常32位字体，一个进程的虚拟地址空间就是4G，栈，堆，数据段，代码段公用这4G","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://miracle-qsh.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://miracle-qsh.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2020-03-08T11:37:47.169Z","updated":"2020-04-08T00:48:07.000Z","comments":true,"path":"2020/03/08/计算机网络/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"计算机网络的总结，结合常见问题","text":"计算机网络的总结，结合常见问题 OSI七层模型物理层、链路层、网络层、传输层、应用层、会话层、表示层 各层的作用应用层：为应用程序提供数据传输服务 传输层：为进程提供数据传输服务 网络层：为主机提供数据传输服务 链路层：为同一链路主机提供数据传输服务 物理层：考虑怎样传输比特流 每一层有哪些协议，各自有什么作用应用层：HTTP协议（请求响应协议）DNS协议（域名解析） 传输层：TCP/UDP协议（传输控制协议） 网络层：ARP协议（MAC地址解析）IP协议（网络之间通信）ICMP协议（传输控制报文） 链路层：PPP协议（点对点传输） TCP/IP网络模型网络接口层、IP层、TCP/UDP层、应用层 TCP/IP协议的特点完全开发、独立于网络硬件系统、网络地址统一分配、高层协议标准化 什么是以太网，它有什么特点以太网是一种星型拓扑结构的局域网 MAC帧的结构目的地址、源地址、类型（上层协议）、数据（46-1500）、FCS（帧检验序列，CRC方法） 集线器、交换机、路由器的作用，已经它们工作在哪一层集线器提供各种物理接口，工作在物理层 交换机提供数据交互功能，工作在链路层 路由器起寻找、导向作用，工作在网络层 IP数据报常见字段的作用版本：4和6两种 首部长度 区分服务（一般不使用） 总长度：首部长度+数据长度 生存时间（TTL）：防止绕圈子 协议：携带数据应该交给哪个协议 首部检验和 标识：相同数据不同分片拥有相同标识 片偏移：数据偏移量 ARP协议的作用实现由IP地址得到MAC地址 维护ARP缓存的过程从ARP高速缓存中查找IP，如果有，直接使用 如果没有，广播ARP请求分组 目的主机收到请求分组后向源主机发送IP到MAC的映射，同时储存源主机IP到MAC的映射 源主机收到响应分组后存储IP到MAC的映射 介绍一下ICMP协议控制报文协议，用于在IP主机、路由器之间传递控制信息（主机是否可达，网络通不通） ICMP报文种类及作用差错报告报文（终点不可达3，超时11，参数问题12，改变路由5）询问报文（回送请求和回答Echo8/0，时间戳请求或回答Timestamp13/14） ICMP数据报与IP数据报的关系ICMP是为了更有效的转发IP数据报和提高交付成功的机会的协议，封装在IP数据报中，不属于高层协议 UDP的特点无连接，尽最大可能交付（不可靠），没有拥塞控制，面向报文，提供一对一、一对多、多对一、多对多交互通信（半双工） UDP的首部格式伪首部（为了计算检验和临时添加）源端口、目的端口、长度、检验和 TCP的特点面向连接，可靠传输，有流量控制，拥塞控制，全双工，面向字节流，只能一对一 TCP的首部格式源端口，目的端口，序列号，确认号，数据偏移（首部长度），URG（紧急指针），PSH（推送），RST（重新连接），SYN（同步），FIN（终止），ACK（确认），窗口（设置窗口大小） UDP与TCP的区别UDP无连接，TCP面向连接 UDP不可靠，TCP可靠 UDP没有拥塞控制，TCP有拥塞控制 UDP面向报文，TCP面向字节流 UDP支持一对一，一对多，多对一，多对多，TCP只支持一对一 UDP开销小，TCP开销大 使用UDP和TCP的协议有哪些UDP：DNS、RIP（动态路由选择协议） TCP：SMTP、TELNET、HTTP、FTP 如何绑定TCP/UDP端口使用bind函数 介绍一下hosthost是指与internet以TCP/IP协议项链的任何计算机 介绍一下hostshosts是一个没有拓展名的系统文件，作用就是把常用的网址域名与对应的IP地址建立一个关联数据库 三次握手过程SYN=1,seq=x SYN=1,ACK=1,seq=y,ack=x+1 ACK=1,seq=x+1,ack=y+1 三次握手原因第三次握手时为了防止失效的连接请求到达服务器，让服务器错误打开连接 四次挥手过程FIN=1,seq=u ACK=1,seq=v,ack=u+1 FIN=1=1,ACK=1,seq=w,ack=u+1 ACK=1,seq=u+1,ack=w+1 四次挥手原因客户端发送FIN之后进入CLOSE-WAIT状态，为了让服务端发送未传送完毕的数据 TIME_WAIT的作用客户端接收到服务端FIN后，没有立即结束，而是等待2MSL的时间，确保最后一个报文能够到达，让本连接发送的报文都从网络中消失 可靠传输原理超时重传 设计可靠的UDP协议等待一段时间之后如果没收到响应，就重新传输报文 TCP拥塞控制的原理慢开始，拥塞避免，快重传，快恢复 DNS端口号，使用什么协议53，通常使用UDP DNS怎么减少传输时间更换DNS提供商，修改DNS缓存是生存周期，使用CDN DNS协议原理ARP协议广播解析MAC地址 发送DNS查询报文，经网关后路由转发，到达DNS服务器后查询IP地址，并原路返回 什么是CDNCDN是构建在现有网络上的智能虚拟网络，通过部署在各地的边缘服务器，使用户九讲获取资源，降低网络拥塞 介绍一下缓存位于内存中，用于缓解服务器压力，降低客户端获取资源的延迟 什么是负载均衡将一个任务分摊到多个操作单元上进行 GET与POST区别GET用于获取资源，POST用于传输实体主体 GET参数传递在URL中，只支持ASCII码，POST在实体主体中 GET安全，POST不安全（改变服务器数据） GET是幂等的，POST是不幂等的 GET可缓存，POST大多数情况下不可缓存 HTTP状态码100目前很正常，200成功，204成功但响应不包含主体，206范围请求，301永久重定向，302临时重定向，400报文语法错误，401认证失败，403请求被拒绝，404页面丢失，500执行请求时发生错误，503无法处理请求 Cookie的作用会话状态管理，个性化设置，浏览器行为跟踪 Cookie是怎样被设置到浏览器的服务器发送响应报文包含Set-Cookie首部字段，客户端得到响应报文后将Cookie内容保存到浏览器 Cookie和Session的比较Cookie存储在浏览器，Session存储在服务器 Cookie限制了数据量（4KB），Session不限量 Cookie不安全，Session安全 Cookie可以设置生存周期，Session不行 Cookie开销小，Session开销大 介绍一下缓存的Cache-Control字段Expires和max-age区别Expries：绝对时间，max-age：相对时间 长连接与短连接的原理及应用场景短连接：一次HTTP通信建立一次TCP连接，应用于用户无需频繁操作，不需要一直获取服务端反馈情况 长连接：建立一次TCP连接，进行多次HTTP通信，应用于操作频繁，点对点通信，而且连接次数不能太多的情况 介绍一下流水线在同一条长连接上连续发出请求，而不用等待响应返回 HTTP存在的安全问题使用明文通信，可能被窃听 不验证身份，可能遭遇伪装 无法验证报文完整性，报文可能被篡改 介绍一下HTTPSHTTP+SSL隧道技术，端口443 HTTPS特点加密，认证，完整性保护 HTTPS加密过程服务端发送公钥给客户端，客户端生成一个随机数，产生密钥，使用公钥进行加密，将加密后的密文传输给服务端，服务端使用私钥进行解密。客户端与服务端使用密钥进行通信 什么是数字签名，有什么作用服务端运营人员向CA提出公钥申请，CA对公钥添加数字签名，作用时完成身份认证 HTTPS认证过程服务端发送证书，客户端使用数字签名进行认证 介绍一下HTTPS的完整性保护认证和加密机制保证了HTTPS的完整性保护的特点 HTTP1.x的缺陷客户端需要使用多连接才能实现并发和减少延迟 不会压缩请求和响应首部 不支持有效的资源优先级 HTTP2的特点二进制分帧层、服务端推送、首部压缩 HTTP1.1的新特性默认长连接、支持流水线、支持多个TCP连接，新增状态码100，新增max-age HTTP与FTP比较HTTP访问网页，FTP传输文件 HTTP一个连接，FTP两个连接 HTTP端口80，FTP端口20/21（21控制） HTTP传输文件小，FTP文件大 HTTP无法验证，FTP有验证 浏览器输入一个url后发生了哪些ARP协议MAC地址解析，DNS域名解析，建立TCP连接，发送HTTP请求，响应，渲染 什么是XSS攻击利用网页开发留下的漏洞，注入恶意指令到网页 输入一个url，如何改变成HTTPS，怎么确定用HTTP还是HTTPS服务器监听HTTP80端口，如果服务端购买认证证书，由302重定向到HTTPS","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://miracle-qsh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://miracle-qsh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Linux","slug":"Linux","date":"2020-03-08T10:58:44.027Z","updated":"2020-04-08T00:48:42.797Z","comments":true,"path":"2020/03/08/Linux/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/08/Linux/","excerpt":"Linux的总结","text":"Linux的总结 常用操作及概念快捷键 Tab：命令和文件名补全 Ctrl+C：中断正在运行的程序 Ctrl+D：结束键盘输入（EOF） 求助–help指令的基本用法与选项介绍 man将指令的具体信息显示出来 info与man类似，做了分页处理 doc/usr/share/doc存放着软件的一整套说明文件 关机who查看在线用户 sync内存磁盘同步操作 shutdown-k 不会关机，只发送警告 -r 将系统服务停掉后重启 -h 将系统服务停掉后关机 -c 取消正在进行的shutdown PATH可以在环境变量中声明可执行文件的路径，路径间以：分割 1&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;home&#x2F;dmtsai&#x2F;.local&#x2F;bin:&#x2F;home&#x2F;dmtsai&#x2F;bin sudosudo允许一般用户使用root可执行的命令 包管理工具 RPM依赖管理和软件升级 DPKG与RPM相似 VIM三个模式 一般指令模式：VIM默认模式，可用游标查看内容 编辑模式：按下i键后进入，可对文本进行编辑 指令列模式：按下:键进入，用于保存退出等操作 在指令列模式下，有以下命令用于离开或者保存文件 命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 磁盘磁盘接口 IDE SATA SCSI SAS 磁盘的文件名Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下： IDE 磁盘：/dev/hd[a-d] SATA/SCSI/SAS 磁盘：/dev/sd[a-p] 其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关 分区分区表MBRMBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。 分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。 Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。 GPT扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为 512 bytes，而最新的磁盘支持 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。 GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。 GPT 没有扩展分区概念，都是主分区，每个 LBA 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。 MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 233 TB = 8 ZB。 开机检测程序 BIOS：不可以读取GPT分区表 UEFI：可用读取GPT分区表 文件系统分区与文件系统对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统 组成 inode：一个文件占有一个inode，记录文件属性，同时记录此文件的内容所在的block编号 block：记录文件内容，文件太大时会占用多个block superblock：记录文件系统的整体信息，包括inode和block的总量、使用量、剩余量、以及文件系统的格式与相关信息 block bitmap：记录block是否被使用的位图 文件读取 Ext2文件系统：现在indoe中查找文件内容所在的block，然后把所有block内容读取出来 FAT文件系统：每个block中存储下一个block的编号 磁盘碎片指一个文件内容所在的block过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能 block在Ext2文件系统中支持block的大小有1K、2K、4K三种，不同大小限制了单个文件和文件系统的最大大小 大小 1KB 2KB 4KB 最大单一文件 16GB 256GB 2TB 最大文件系统 2TB 8TB 16TB 一个block只能被一个文件使用，未使用部分直接浪费 inode具体信息包含： 权限 拥有者与群组 容量 建立或状态改变的时间 最近读取时间 最近修改时间 定义文件特性的旗标（flag），如SetUID 该文件真正内容指向 inode特点： 每个indoe大小固定128 bytes 每个文件只占有一个indoe indoe通过间接引用让block记录引用信息（下一个block） 目录建立一个目录时，会分配一个indoe和至少一个block。block记录的内容是目录下所有文件的indoe编号以及文件名 文件的indoe本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关 日志如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。 ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统 挂载挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。 目录配置为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下： / (root, 根目录) /usr (unix software resource)：所有系统默认软件都会安装到这个目录； /var (variable)：存放系统或程序运行过程中的数据文件。 文件文件属性用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。 使用 ls 查看一个文件时，会显示一个文件的信息，例如 drwxr-xr-x 3 root root 17 May 6 00:14 .config，对这个信息的解释如下： drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段 3：链接数 root：文件拥有者 root：所属群组 17：文件大小 May 6 00:14：文件最后被修改的时间 .config：文件名 常见的文件类型及其含义有： d：目录 -：文件 l：链接文件 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。 文件时间有以下三种： modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 文件与目录的基本操作ls列出文件或者目录的信息，目录的信息就是其中包含的文件。 1# ls [-aAdfFhilnrRSt] file|dir2-a ：列出全部的文件3-d ：仅列出目录本身4-l ：以长数据串行列出，包含文件的属性与权限等等数据 cd更换当前目录。 1cd [相对路径或绝对路径] mkdir创建目录。 1# mkdir [-mp] 目录名称2-m ：配置目录权限3-p ：递归创建目录 rmdir删除目录，目录必须为空。 1rmdir [-p] 目录名称2-p ：递归删除目录 touch更新文件时间或者建立新文件。 1# touch [-acdmt] filename2-a ： 更新 atime3-c ： 更新 ctime，若该文件不存在则不建立新文件4-m ： 更新 mtime5-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=\"日期或时间\"6-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] cp复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。 1cp [-adfilprsu] source destination2-a ：相当于 -dr --preserve=all3-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身4-i ：若目标文件已经存在时，在覆盖前会先询问5-p ：连同文件的属性一起复制过去6-r ：递归复制7-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制8--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 rm删除文件。 1# rm [-fir] 文件或目录2-r ：递归删除 mv移动文件。 1# mv [-fiu] source destination2# mv [options] source1 source2 source3 .... directory3-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 修改权限可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 1# chmod [-R] xyz dirname/filenameCopy to clipboardErrorCopied 示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。 1# chmod 754 .bashrcCopy to clipboardErrorCopied 也可以使用符号来设定权限。 1# chmod [ugoa] [+-=] [rwx] dirname/filename2- u：拥有者3- g：所属群组4- o：其他人5- a：所有人6- +：添加权限7- -：移除权限8- =：设定权限Copy to clipboardErrorCopied 示例：为 .bashrc 文件的所有用户添加写权限。 1# chmod a+w .bashrc 默认权限 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–。 目录的权限文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。 目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了 链接实体链接在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。 删除任意一个条目，文件还是存在，只要引用数量不为 0。 有以下限制：不能跨越文件系统、不能对目录进行链接。 符号链接符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。 当源文件被删除了，链接文件就打不开了。 因为记录的是路径，所以可以为目录建立符号链接。 获取文件内容cat取得文件内容。 1# cat [-AbEnTv] filename2-n ：打印出行号，连同空白行也会有行号，-b 不会 tac是 cat 的反向操作，从最后一行开始打印。 more和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。 less和 more 类似，但是多了一个向前翻页的功能。 head取得文件前几行。 1# head [-n number] filename2-n ：后面接数字，代表显示几行的意思 tail是 head 的反向操作，只是取得是后几行。 od以字符或者十六进制的形式显示二进制文件。 指令与文件搜索which指令搜索。 1# which [-a] command2-a ：将所有指令列出，而不是只列第一个 whereis文件搜索。速度比较快，因为它只搜索几个特定的目录。 1# whereis [-bmsu] dirname/filename locate文件搜索。可以用关键字或者正则表达式进行搜索。 locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。 1# locate [-ir] keyword2-r：正则表达式 find文件搜索。可以使用文件的属性和权限进行搜索。 1# find [basedir] [option]2example: find . -name \"shadow*\"Copy to clipboardErrorCopied ① 与时间有关的选项 1-mtime n ：列出在 n 天前的那一天修改过内容的文件2-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件3-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件4-newer file ： 列出比 file 更新的文件Copy to clipboardErrorCopied +4、4 和 -4 的指示的时间范围如下： ② 与文件拥有者和所属群组有关的选项 1-uid n2-gid n3-user name4-group name5-nouser ：搜索拥有者不存在 /etc/passwd 的文件6-nogroup：搜索所属群组不存在于 /etc/group 的文件Copy to clipboardErrorCopied ③ 与文件权限和名称有关的选项 1-name filename2-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k3-type TYPE4-perm mode ：搜索权限等于 mode 的文件5-perm -mode ：搜索权限包含 mode 的文件6-perm /mode ：搜索权限包含任一 mode 的文件 压缩与打包压缩文件名Linux 底下有很多压缩文件名，常见的如下： 扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 压缩指令gzipgzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。 经过 gzip 压缩过，源文件就不存在了。 有 9 个不同的压缩等级可以使用。 可以使用 zcat、zmore、zless 来读取压缩文件的内容。 1$ gzip [-cdtv#] filename2-c ：将压缩的数据输出到屏幕上3-d ：解压缩4-t ：检验压缩文件是否出错5-v ：显示压缩比等信息6-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 bzip2提供比 gzip 更高的压缩比。 查看命令：bzcat、bzmore、bzless、bzgrep。 1$ bzip2 [-cdkzv#] filename2-k ：保留源文件 xz提供比 bzip2 更佳的压缩比。 可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。 查看命令：xzcat、xzmore、xzless、xzgrep。 1$ xz [-dtlkc#] filename 打包压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。 1$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩2$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看3$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩4-z ：使用 zip；5-j ：使用 bzip2；6-J ：使用 xz；7-c ：新建打包文件；8-t ：查看打包文件里面有哪些文件；9-x ：解打包或解压缩的功能；10-v ：在压缩/解压缩的过程中，显示正在处理的文件名；11-f : filename：要处理的文件；12-C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 Bash可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。 特性 命令历史：记录使用过的命令 命令与文件补全：快捷键：tab 命名别名：例如 ll 是 ls -al 的别名 shell scripts 通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件 变量操作对一个变量赋值直接使用 =。 对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式； 输出变量使用 echo 命令。 1$ x=abc2$ echo $x3$ echo $&#123;x&#125;Copy to clipboardErrorCopied 变量内容如果有空格，必须使用双引号或者单引号。 双引号内的特殊字符可以保留原本特性，例如 x=”lang is $LANG”，则 x 的值为 lang is zh_TW.UTF-8； 单引号内的特殊字符就是特殊字符本身，例如 x=’lang is $LANG’，则 x 的值为 lang is $LANG。 可以使用 指令 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。 可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。 Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令： 1$ declare [-aixr] variable2-a ： 定义为数组类型3-i ： 定义为整数类型4-x ： 定义为环境变量5-r ： 定义为 readonly 类型Copy to clipboardErrorCopied 使用 [ ] 来对数组进行索引操作： 1$ array[1]=a2$ array[2]=b3$ echo $&#123;array[1]&#125; 指令搜索顺序 以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ； 由别名找到该指令来执行； 由 Bash 内置的指令来执行； 按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。 数据流重定向重定向指的是使用文件代替标准输入、标准输出和标准错误输出。 1 代码 运算符 标准输入 (stdin) 0 &lt; 或 &lt;&lt; 标准输出 (stdout) 1 &gt; 或 &gt;&gt; 标准错误输出 (stderr) 2 2&gt; 或 2&gt;&gt; 其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。 可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。 如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。 1$ find /home -name .bashrc &gt; list 2&gt;&amp;1 管道命令管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。 在命令之间使用 | 分隔各个管道命令。 1$ ls -al /etc | less 提取指令cut 对数据进行切分，取出想要的部分。 切分过程一行一行地进行。 1$ cut2-d ：分隔符3-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间4-c ：以字符为单位取出区间Copy to clipboardErrorCopied 示例 1：last 显示登入者的信息，取出用户名。 1$ last2root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in3root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)4root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)56$ last | cut -d ' ' -f 1Copy to clipboardErrorCopied 示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。 1$ export2declare -x HISTCONTROL=\"ignoredups\"3declare -x HISTSIZE=\"1000\"4declare -x HOME=\"/home/dmtsai\"5declare -x HOSTNAME=\"study.centos.vbird\"6.....(其他省略).....78$ export | cut -c 12- 排序指令sort 用于排序。 1$ sort [-fbMnrtuk] [file or stdin]2-f ：忽略大小写3-b ：忽略最前面的空格4-M ：以月份的名字来排序，例如 JAN，DEC5-n ：使用数字6-r ：反向排序7-u ：相当于 unique，重复的内容只出现一次8-t ：分隔符，默认为 tab9-k ：指定排序的区间Copy to clipboardErrorCopied 示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。 1$ cat /etc/passwd | sort -t ':' -k 32root:x:0:0:root:/root:/bin/bash3dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash4alex:x:1001:1002::/home/alex:/bin/bash5arod:x:1002:1003::/home/arod:/bin/bashCopy to clipboardErrorCopied uniq 可以将重复的数据只取一个。 1$ uniq [-ic]2-i ：忽略大小写3-c ：进行计数Copy to clipboardErrorCopied 示例：取得每个人的登录总次数 1$ last | cut -d ' ' -f 1 | sort | uniq -c2136 (unknown447 dmtsai54 reboot67 root71 wtmp 双向输出重定向输出重定向会将输出内容重定向到文件中，而 tee 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。 1$ tee [-a] file 字符转换指令tr 用来删除一行中的字符，或者对字符进行替换。 1$ tr [-ds] SET1 ...2-d ： 删除行中 SET1 这个字符串Copy to clipboardErrorCopied 示例，将 last 输出的信息所有小写转换为大写。 1$ last | tr '[a-z]' '[A-Z]'Copy to clipboardErrorCopied col 将 tab 字符转为空格字符。 1$ col [-xb]2-x ： 将 tab 键转换成对等的空格键Copy to clipboardErrorCopied expand 将 tab 转换一定数量的空格，默认是 8 个。 1$ expand [-t] file2-t ：tab 转为空格的数量Copy to clipboardErrorCopied join 将有相同数据的那一行合并在一起。 1$ join [-ti12] file1 file22-t ：分隔符，默认为空格3-i ：忽略大小写的差异4-1 ：第一个文件所用的比较字段5-2 ：第二个文件所用的比较字段Copy to clipboardErrorCopied paste 直接将两行粘贴在一起。 1$ paste [-d] file1 file22-d ：分隔符，默认为 tab 分区指令split 将一个文件划分成多个文件。 1$ split [-bl] file PREFIX2-b ：以大小来进行分区，可加单位，例如 b, k, m 等3-l ：以行数来进行分区。4- PREFIX ：分区文件的前导名称 正则表达式grepg/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。 1$ grep [-acinv] [--color=auto] 搜寻字符串 filename2-c ： 统计匹配到行的个数3-i ： 忽略大小写4-n ： 输出行号5-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行6--color=auto ：找到的关键字加颜色显示Copy to clipboardErrorCopied 示例：把含有 the 字符串的行提取出来（注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串） 1$ grep -n 'the' regular_express.txt28:I can't finish the test.312:the symbol '*' is represented as start.415:You are the best is mean you are the no. 1.516:The world Happy is the same with \"glad\".618:google is the best tools for search keywordCopy to clipboardErrorCopied 示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。 1$ grep -n 'a\\&#123;2,5\\&#125;' regular_express.txt printf用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。 1$ printf '%10s %5i %5i %5i %8.2f \\n' $(cat printf.txt)2 DmTsai 80 60 92 77.333 VBird 75 55 80 70.004 Ken 60 90 70 73.33 awk是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。 awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。 示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。 1$ last -n 52dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in3dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)4dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)5dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)6dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)Copy to clipboardErrorCopied7$ last -n 5 | awk '&#123;print $1 \"\\t\" $3&#125;'Copy to clipboardErrorCopied 可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。 1$ awk '条件类型 1 &#123;动作 1&#125; 条件类型 2 &#123;动作 2&#125; ...' filenameCopy to clipboardErrorCopied 示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。 1$ cat &#x2F;etc&#x2F;passwd | awk &#39;BEGIN &#123;FS&#x3D;&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\\t &quot; $3&#125;&#39;2root 03bin 14daemon 2Copy to clipboardErrorCopied awk 变量： 变量名称 代表意义 NF 每一行拥有的字段总数 NR 目前所处理的是第几行数据 FS 目前的分隔字符，默认是空格键 示例：显示正在处理的行号以及每一行有多少字段 1$ last -n 5 | awk '&#123;print $1 \"\\t lines: \" NR \"\\t columns: \" NF&#125;'2dmtsai lines: 1 columns: 103dmtsai lines: 2 columns: 104dmtsai lines: 3 columns: 105dmtsai lines: 4 columns: 106dmtsai lines: 5 columns: 9 进程管理查看进程ps查看某个时间点的进程信息。 示例：查看自己的进程 1# ps -lCopy to clipboardErrorCopied 示例：查看系统所有进程 1# ps auxCopy to clipboardErrorCopied 示例：查看特定的进程 1# ps aux | grep threadx pstree查看进程树。 示例：查看所有进程树 1# pstree -A top实时显示进程信息。 示例：两秒钟刷新一次 1# top -d 2 netstat查看占用端口的进程 示例：查看特定端口的进程 1# netstat -anp | grep port 进程状态 状态 说明 R running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。 D uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞。 S interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。 Z zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息。 T stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。 SIGCHLD当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中： 得到 SIGCHLD 信号； waitpid() 或者 wait() 调用会返回。 其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。 在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。 wait()1pid_t wait(int *status)Copy to clipboardErrorCopied 父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。 如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。 参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL waitpid()1pid_t waitpid(pid_t pid, int *status, int options)Copy to clipboardErrorCopied 作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。 pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。 options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。 孤儿进程一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。 孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。 由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害 僵尸进程一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。 僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。 系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程 参考资料CS-Notes","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://miracle-qsh.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://miracle-qsh.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"Linux","permalink":"http://miracle-qsh.github.io/tags/Linux/"}]},{"title":"数据库系统原理","slug":"数据库系统原理","date":"2020-03-07T13:19:59.788Z","updated":"2020-04-08T00:49:17.693Z","comments":true,"path":"2020/03/07/数据库系统原理/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/","excerpt":"数据库系统原理的总结","text":"数据库系统原理的总结 事务什么是事务事务指满足ACID特性的一组操作 ACID是什么原子性、一致性、隔离性、持久性 什么是原子性要么操作全部成功，要么全部失败 原子性实现原理innoDB实现回滚，靠的是undo log，通过undo log做与之前相反的操作实现回滚，保证原子性 什么是一致性所有事务对同一数据的读取结果相同 一致性实现原理原子性、隔离性、持久性以及应用层的保障 什么是隔离性一个事务完成前，对其他事务不可见 隔离性实现原理锁机制和MVCC 什么是持久性一旦事务提交（完成），则所作修改永远保存 持久性实现原理innoDB通过缓存（Buffer Pool，定期刷盘）提高读写数据效率，但MySQL宕机时会导致数据丢失，于是引入redo log，当数据修改时，先在redo log中记录本次操作所有修改，之后修改Buffer Pool数据；事务提交时，会调用fsync接口对redo log进行刷盘，如果宕机，重启时可以读取redo log中的数据，对数据库进行恢复 redo log与bin log的区别作用不同：redo log保证宕机也不会影响持久性，bin log保证服务器可以基于时间点恢复数据和主从复制 层次不同：redo log时innoDB存储引擎实现的，bin log时服务器层实现的 内容不同：redo log是物理日志，内容基于磁盘Page；bin log内容是二进制的 写入时机不同：bin log在事务提交时写入； redo log写入时间相对多元 锁机制按照粒度，分为表锁和行锁 读写锁X：写锁（互斥锁）、S：读锁（共享锁） 意向锁一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。 封锁协议三级封锁协议 一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁 二级封锁协议：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁 三级封锁协议：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁 两段锁协议加索和解锁分两个阶段进行 隐式与显示锁定MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。 InnoDB 也可以使用特定的语句进行显示锁定： 1select ... lock in share mode;2select ... for update; 并发一致性问题丢失修改、脏读、不可重复读、幻影读 什么是丢失修改A和B对同一数据修改，A改完后B改，A修改被覆盖 什么是脏读A修改数据，B读取该数据，随后A撤销本次修改 什么是不可重复读A读数据，B对该数据进行修改，A再读取该数据 什么是幻影读A读某个范围数据，B在该范围内插入新数据，A再读该范围数据 事务隔离级别未提交读、提交读、可重复读、可串行化 未提交读未提交的事务对其他事务也有可见性 提交读一个事务提交前对其他事务不可见 可重复读保证在同一事务多次读取同一数据结果一致 可串行化强制事务串行执行 MVCC同一时刻不同事务读取的版本可能不同 解决脏读 解决不可重复读 解决幻影读 范式理论函数依赖A-&gt;B：B依赖A，A决定B 如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码 对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖 对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖 异常以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。 Sno Sname Sdept Mname Cname Grade 1 学生-1 学院-1 院长-1 课程-1 90 2 学生-2 学院-2 院长-2 课程-2 80 2 学生-2 学院-2 院长-2 课程-1 100 3 学生-3 学院-2 院长-2 课程-2 95 不符合范式的关系，会产生很多异常，主要有以下四种异常： 冗余数据：例如 学生-2 出现了两次。 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 课程-1 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。 范式第一范式属性不可分 第二范式每个非主属性完全函数依赖于键码。 可以通过分解来满足。 分解前 Sno Sname Sdept Mname Cname Grade 1 学生-1 学院-1 院长-1 课程-1 90 2 学生-2 学院-2 院长-2 课程-2 80 2 学生-2 学院-2 院长-2 课程-1 100 3 学生-3 学院-2 院长-2 课程-2 95 以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖： Sno -&gt; Sname, Sdept Sdept -&gt; Mname Sno, Cname-&gt; Grade Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。 Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。 分解后 关系-1 Sno Sname Sdept Mname 1 学生-1 学院-1 院长-1 2 学生-2 学院-2 院长-2 3 学生-3 学院-2 院长-2 有以下函数依赖： Sno -&gt; Sname, Sdept Sdept -&gt; Mname 关系-2 Sno Cname Grade 1 课程-1 90 2 课程-2 80 2 课程-1 100 3 课程-2 95 有以下函数依赖： Sno, Cname -&gt; Grade 第三范式非主属性不传递函数依赖于键码。 上面的 关系-1 中存在以下传递函数依赖： Sno -&gt; Sdept -&gt; Mname 可以进行以下分解： 关系-11 Sno Sname Sdept 1 学生-1 学院-1 2 学生-2 学院-2 3 学生-3 学院-2 关系-12 Sdept Mname 学院-1 院长-1 学院-2 院长-2 参考资料：深入学习MySQL事务：ACID特性的实现原理 CS-Notes","categories":[{"name":"数据库","slug":"数据库","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"STL及常用算法","slug":"STL及常用算法","date":"2020-03-07T09:16:23.224Z","updated":"2020-03-07T09:17:05.275Z","comments":true,"path":"2020/03/07/STL及常用算法/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/STL%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","excerpt":"STL及常用算法的总结","text":"STL及常用算法的总结 STL1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3struct node4&#123;5 int data;6 bool operator &lt; (const node &amp;b)const&#123; &#x2F;&#x2F;重载运算符7 return data &lt; b.data;8 &#125;9&#125;;10int main()11&#123;12 &#x2F;&#x2F;队列13 queue&lt;int&gt;qu;14 queue&lt;node&gt;qu;15 &#x2F;&#x2F;优先队列16 priority_queue&lt;int&gt;qu; &#x2F;&#x2F;从大到小17 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;qu; &#x2F;&#x2F;从小到大18 priority_queue&lt;node&gt;qu; &#x2F;&#x2F;结构体19 qu.push(&#123;1&#125;);20 qu.push(&#123;2&#125;);21 cout &lt;&lt; qu.top().data &lt;&lt; endl;22 &#x2F;&#x2F;集合23 set&lt;int&gt;st;24 st.insert(1);25 set&lt;int&gt;::iterator it;26 it &#x3D; st.lower_bound(1);27 st.insert(st.begin(), st.end());28 &#x2F;&#x2F;映射29 map&lt;int,int&gt;mp;30 map&lt;int,int&gt;::iterator it;31 mp[1] &#x3D; 2;32 it &#x3D; mp.lower_bound(1);33 cout &lt;&lt; it-&gt;second &lt;&lt; endl;3435&#125; 并查集1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3const int maxn &#x3D; 10010;4int pre[maxn];5int fin(int x)&#123;return x &#x3D;&#x3D; pre[x] ? x : pre[x] &#x3D; fin(pre[x]);&#125;6int main()7&#123;8 int n &#x3D; maxn;9 for(int i &#x3D; 0; i &lt;&#x3D; n; i++)pre[i] &#x3D; i;10 int x &#x3D; fin(1);11 int y &#x3D; fin(2);12 if(x !&#x3D; y)pre[x] &#x3D; y;13&#125; 搜索 DFS &amp;&amp; BFS1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3const int maxn &#x3D; 10010;4vector&lt;int&gt;mp[maxn];5int n, vis[maxn] &#x3D; &#123;0&#125;;6void dfs(int x)7&#123;8 vis[x] &#x3D; 1;9 for(int i &#x3D; 0; i &lt; mp[x].size(); i++)10 &#123;11 int v &#x3D; mp[x][i];12 if(vis[v] &#x3D;&#x3D; 0)13 &#123;14 dfs(v);15 &#125;16 &#125;17 vis[x] &#x3D; 0;18&#125;19void bfs(int x)20&#123;21 queue&lt;int&gt;qu;22 qu.push(x);23 vis[x] &#x3D; 1;24 while(!qu.empty())25 &#123;26 int w &#x3D; qu.front();27 qu.pop();28 for(int i &#x3D; 0; i &lt; mp[w].size(); i++)29 &#123;30 int v &#x3D; mp[w][i];31 if(vis[v] &#x3D;&#x3D; 0)32 &#123;33 qu.push(v);34 vis[v] &#x3D; 1;35 &#125;36 &#125;37 &#125;38&#125; 最短路 Dijstra &amp;&amp; Floyd &amp;&amp; SPFA1int main()2&#123;3 mp[1].push_back(2);4 mp[2].push_back(1);5 dfs(1);6 bfs(1);7&#125;89#include &lt;bits&#x2F;stdc++.h&gt;10#define inf 0x3f3f3f11using namespace std;12const int maxn &#x3D; 1010;13int mp[maxn][maxn] &#x3D; &#123;0&#125;;14int n &#x3D; 3, st &#x3D; 1, ed &#x3D; 3;15void dij()16&#123;17 int dis[maxn], vis[maxn] &#x3D; &#123;0&#125;;18 for(int i &#x3D; 0; i &lt;&#x3D; n; i++)dis[i] &#x3D; inf;19 vis[st] &#x3D; 1;20 dis[st] &#x3D; 0;21 for(int i &#x3D; 0; i &lt; n; i++)22 &#123;23 int u &#x3D; -1, minn &#x3D; inf;24 for(int j &#x3D; 1; j &lt;&#x3D; n; j++)25 &#123;26 if(dis[j] &lt; minn)27 &#123;28 minn &#x3D; dis[j];29 u &#x3D; j;30 &#125;31 &#125;32 if(u &gt; 0)vis[u] &#x3D; 1;33 else continue;34 for(int j &#x3D; 1; j &lt;&#x3D; n; j++)35 &#123;36 if(vis[j] &#x3D;&#x3D; 0 &amp;&amp; dis[j] &gt; dis[u] + mp[u][j])37 &#123;38 dis[j] &#x3D; dis[u] + mp[u][j];39 &#125;40 &#125;41 &#125;42&#125;43void floyd()44&#123;45 int i, j, k;46 for(k &#x3D; 1; k &lt;&#x3D; n; k++)47 &#123;48 for(i &#x3D; 1; i &lt;&#x3D; n; i++)49 &#123;50 for(j &#x3D; 1; j &lt;&#x3D; n; j++)51 &#123;52 if(mp[i][j] &gt; mp[i][k] + mp[k][j])53 &#123;54 mp[i][j] &#x3D; mp[i][k] + mp[k][j];55 &#125;56 &#125;57 &#125;58 &#125;59&#125;60int spfa()61&#123;62 int vis[maxn] &#x3D; &#123;0&#125;, dis[maxn], cnt[maxn] &#x3D; &#123;0&#125;;63 for(int i &#x3D; 1; i &lt;&#x3D; n; i++)dis[i] &#x3D; inf;64 dis[st] &#x3D; 0;65 queue&lt;int&gt;qu;66 qu.push(st);67 vis[st] &#x3D; 1;68 cnt[st]++;69 while(!qu.empty())70 &#123;71 int w &#x3D; qu.front();72 qu.pop();73 for(int i &#x3D; 1; i &lt;&#x3D; n; i++)74 &#123;75 if(vis[i] &#x3D;&#x3D; 0 &amp;&amp; dis[i] &gt; dis[w] + mp[w][i])76 &#123;77 dis[i] &#x3D; dis[w] + mp[w][i];78 vis[i] &#x3D; 1;79 qu.push(i);80 cnt[i]++;81 &#125;82 &#125;83 vis[w] &#x3D; 0;84 &#125;85 return dis[ed];86&#125;87int main()88&#123;89 mp[1][2] &#x3D; mp[2][1] &#x3D; 1;90 mp[1][3] &#x3D; mp[3][1] &#x3D; 2;91 mp[2][3] &#x3D; mp[3][2] &#x3D; 4;92 cout &lt;&lt; spfa();93&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Polya","slug":"Polya","date":"2020-03-07T09:15:41.589Z","updated":"2020-03-07T09:16:08.216Z","comments":true,"path":"2020/03/07/Polya/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/Polya/","excerpt":"Polya的总结","text":"Polya的总结 Step1 - Polya-定理设 G 是 n 个对象的一个置换群, 用m种颜色染图这 n 个对象，则不同的染色方案数为： 其中 G = {P1, P2, P3,…, Pg}, C(Pk) 表示 Pk 的循环节。Step2 - Polya-定理的引入与简单理解参考博客：https://blog.csdn.net/lyc1635566ty/article/details/52545355 参考视频：学堂在线-组合数学 一、前置知识：1.置换：其实就是集合 G 到 G 的一个双射，例如： 也就是说每次变换，1 –&gt; a1，2 –&gt; a2，…，n –&gt; an。 2.置换的乘法：例如定义 P1, P2两个置换。 定义置换乘法： 表示先作 P1 的置换，再作 P2 的置换。 3.Burnside引理:设G={a1,a2,…ag}是目标集[1,n]上的置换群。每个置换都写成不相交循环的乘积。 是在置换ak的作用下不动点的个数，也就是长度为1的循环的个数。通过上述置换的变换操作后可以相等的元素属于同一个等价类。若G将[1,n]划分成l个等价类，则等价类个数为： 二、Polya定理的引出：设 G 是 n 个对象的一个置换群, 用m种颜色染图这 n 个对象，则不同的染色方案数为： 其中 G = {P1, P2, P3,…, Pg}, C(Pk) 表示 Pk 的循环节。 Step3 - Polya-定理的使用 确定置换的个数（旋转角度，翻转） 确定循环节个数（旋转角度时考虑 gcd，翻转时特殊考虑） 套用 Polya 公式 Step4 - Polya定理-例题&amp;&amp;模板（POJ 1286）题目大意：给你一个长度为 n 的项链（环），着 3 种颜色，问有多少种 解题思路： 确定置换个数：旋转 (k * 360 / n)° n 种， 对称反转 n 种， 共 2 * n 种 确定循环节个数，旋转角度 (k * 360 / n)° 循环节为 gcd(n, k)，对称反转分奇数和偶数。 套用 Polya 公式求解 代码+模板：1#include &lt;cstdio&gt;2#include &lt;cmath&gt;3#include &lt;algorithm&gt;4using namespace std;5typedef long long ll;6int main()7&#123;8 ll n, m, i, j, k;9 while(scanf(&quot;%lld&quot;, &amp;n) !&#x3D; EOF)10 &#123;11 if(n &#x3D;&#x3D; -1)break;12 if(n &#x3D;&#x3D; 0)&#123;printf(&quot;0\\n&quot;);continue;&#125;&#x2F;&#x2F;特判013 ll ans &#x3D; 0;14 for(i &#x3D; 1; i &lt;&#x3D; n; i++)ans +&#x3D; pow(3.0, __gcd(n, i) * 1.0);&#x2F;&#x2F;旋转（i * 360 &#x2F; n）°15 if(n % 2 &#x3D;&#x3D; 1)&#123;ans +&#x3D; n * pow(3.0, (n + 1) &#x2F; 2);&#125;&#x2F;&#x2F;奇数16 else &#123;ans +&#x3D; n &#x2F; 2 * pow(3.0, n &#x2F; 2) + n &#x2F; 2 * pow(3.0, n &#x2F; 2 + 1);&#125;&#x2F;&#x2F;偶数17 ans &#x2F;&#x3D; (n * 2);&#x2F;&#x2F;除置换个数18 printf(&quot;%lld\\n&quot;, ans);19 &#125;20 return 0;21&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Manacher","slug":"Manacher","date":"2020-03-07T09:14:34.612Z","updated":"2020-03-07T09:15:10.442Z","comments":true,"path":"2020/03/07/Manacher/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/Manacher/","excerpt":"Manacher的总结","text":"Manacher的总结 题目传送门：POJ-3974 Palindrome题目大意：求最长回文字串 解题思路：Manacher模板题 AC代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4using namespace std;5char a[1000005];6char ma[2000005];7int mp[2000005];8int main()9&#123;10 int ca &#x3D; 1;11 while(scanf(&quot;%s&quot;, a) !&#x3D; EOF &amp;&amp; strcmp(a, &quot;END&quot;) !&#x3D; 0)12 &#123;13 int n &#x3D; strlen(a), i, l &#x3D; 0;14 ma[l++] &#x3D; &#39;$&#39;;15 ma[l++] &#x3D; &#39;#&#39;;16 for(i &#x3D; 0; i &lt; n; i++)17 &#123;18 ma[l++] &#x3D; a[i];19 ma[l++] &#x3D; &#39;#&#39;;20 &#125;21 ma[l] &#x3D; 0;22 int mx &#x3D; 0, id &#x3D; 0;23 int ans &#x3D; 0;24 for(i &#x3D; 0; i &lt; l; i++)25 &#123;26 mp[i] &#x3D; mx &gt; i ? min(mp[2 * id - i], mx - i):1;27 while(ma[i + mp[i]] &#x3D;&#x3D; ma[i - mp[i]])mp[i]++;28 if(i + mp[i] &gt; mx)29 &#123;30 mx &#x3D; i + mp[i];31 id &#x3D; i;32 &#125;33 ans &#x3D; max(ans, mp[i] - 1);34 &#125;35 printf(&quot;Case %d: %d\\n&quot;, ca++, ans);3637 &#125;38 return 0;39&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"KMP","slug":"KMP","date":"2020-03-07T09:13:55.652Z","updated":"2020-03-07T09:14:17.142Z","comments":true,"path":"2020/03/07/KMP/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/KMP/","excerpt":"KMP的总结","text":"KMP的总结 题目传送门：POJ-2406 Power Strings题目大意：给你一个字符串，求它的最小循环节 解题思路：最小循环节==len/（len-next[len]）（如果能整除） AC代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3using namespace std;4char a[1000005];5int nex[1000005];6int main()7&#123;8 while(scanf(&quot;%s&quot;, a) &amp;&amp; a[0] !&#x3D; &#39;.&#39;)9 &#123;10 int len &#x3D; strlen(a);11 int i &#x3D; 0, j &#x3D; -1;12 nex[0] &#x3D; -1;13 while(i &lt; len)14 &#123;15 if(j &#x3D;&#x3D; -1 || a[i] &#x3D;&#x3D; a[j])16 &#123;17 nex[++i] &#x3D; ++j;18 &#125;19 else j &#x3D; nex[j];20 &#125;21 if(len % (len - nex[len]) &#x3D;&#x3D; 0)22 printf(&quot;%d\\n&quot;, len &#x2F; (len - nex[len]));23 else printf(&quot;1\\n&quot;);24 &#125;25 return 0;26&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"AC自动机","slug":"AC自动机","date":"2020-03-07T09:12:52.874Z","updated":"2020-03-07T09:13:42.887Z","comments":true,"path":"2020/03/07/AC自动机/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"AC自动机的总结","text":"AC自动机的总结 P3808 【模板】AC自动机（简单版）1#include&lt;bits/stdc++.h&gt;2using namespace std;3queue&lt;int&gt; q;4const int N = 500010;5struct AC_automaton6&#123;7 int c[N][26], val[N], fail[N], cnt;8 //c数组记录字典树节点，val数组为该节点是否为字符串结尾（个数）（记录字符串结束的位置）， fail记录失配指针， cnt记录节点标号(对应val)9 //cnt作用：模拟动态开点10 void ins(char *s)//向字典树中插入字符串，s为模式串11 &#123;12 int len = strlen(s); int now = 0;//从根节点0开始13 for(int i = 0; i &lt; len; i++)14 &#123;15 int v = s[i] - 'a';//获取当前字符的值16 if(!c[now][v])c[now][v] = ++cnt;//如果这个节点没开，则开点17 now = c[now][v];//now移动到新节点，开始匹配下一个18 &#125;19 val[now]++;//字符串插入完毕后在尾部打标记，val[u]表示以该点结尾的字符串个数20 &#125;21 void build()//获取每个节点的失配指针22 &#123;23 for(int i = 0; i &lt; 26; i++)24 if(c[0][i])fail[c[0][i]] = 0, q.push(c[0][i]);//首先将与根节点相连的点入队，即首字母入队，并赋失配指针为025 while(!q.empty())26 &#123;27 int u = q.front(); q.pop();//出队28 for(int i = 0; i &lt; 26; i++)29 &#123;30 if(c[u][i])fail[c[u][i]] = c[fail[u]][i], q.push(c[u][i]);//如果该节点存在，则他的失配指针为它的上一个失配指针处的失配指针，并入队31 else c[u][i] = c[fail[u]][i];//该点不存在只更新fail指针32 &#125;33 &#125;34 &#125;35 int query(char *s)//查询文本串中模式串的个数，s为文本串36 &#123;37 int len = strlen(s); int now = 0, ans = 0;//ans记录答案（模式串个数）， 从根节点开始38 for(int i = 0; i &lt; len; i++)39 &#123;40 now = c[now][s[i] - 'a'];//从当前节点向下走41 for(int t = now; t &amp;&amp; ~val[t]; t = fail[t])ans += val[t], val[t] = -1;//遍历该节点前失配指针，并统计个数，清楚val（避免重复统计）42 &#125;43 return ans;44 &#125;45&#125;AC;46int n;47char p[1000005];48int main()49&#123;50 scanf(\"%d\", &amp;n);51 for(int i = 1; i &lt;= n; i++)scanf(\"%s\", p), AC.ins(p);52 AC.build();53 scanf(\"%s\", p);54 int ans = AC.query(p);55 printf(\"%d\\n\", ans);56 return 0;57&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"最小费用最大流","slug":"最小费用最大流","date":"2020-03-07T09:12:10.836Z","updated":"2020-03-07T09:12:45.062Z","comments":true,"path":"2020/03/07/最小费用最大流/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/","excerpt":"最小费用最大流的总结","text":"最小费用最大流的总结 P4016 负载平衡问题题目链接https://www.luogu.org/problem/P4016 解题思路分源点、汇点，源点所有超过均值的点流量为1，费用为0、所有未超过均值的点连汇点流量为1，费用为0、相邻两点连边，流量为INF，费用为1，跑最小费用最大流即可。 AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2#define go(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)3#define dip(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)4#define maxn 20105#define maxm 12000106#define inf 0x3f3f3f3f7using namespace std;8struct Edge&#123;9 int to, nex, cap, flow, cost;10&#125;edge[maxm];11int head[maxn], tol, pre[maxn], dis[maxn];12bool vis[maxn];13int N;14void init(int n)&#123;15 N &#x3D; n;16 tol &#x3D; 0;17 memset(head, -1, sizeof(head));18&#125;19void addedge(int u, int v, int cap, int cost)&#123;20 edge[tol].to &#x3D; v;21 edge[tol].cap &#x3D; cap;22 edge[tol].cost &#x3D; cost;23 edge[tol].flow &#x3D; 0;24 edge[tol].nex &#x3D; head[u];25 head[u] &#x3D; tol++;26 edge[tol].to &#x3D; u;27 edge[tol].cap &#x3D; 0;28 edge[tol].cost &#x3D; -cost;29 edge[tol].flow &#x3D; 0;30 edge[tol].nex &#x3D; head[v];31 head[v] &#x3D; tol++;32&#125;33bool spfa(int s, int t)&#123;34 queue&lt;int&gt;q;35 for(int i &#x3D; 0; i &lt; N; i++)&#123;36 dis[i] &#x3D; inf;37 vis[i] &#x3D; false;38 pre[i] &#x3D; -1;39 &#125;40 dis[s] &#x3D; 0;41 vis[s] &#x3D; true;42 q.push(s);43 while(!q.empty())&#123;4445 int u &#x3D; q.front();46 q.pop();47 vis[u] &#x3D; false;48 for(int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; edge[i].nex)&#123;49 int v &#x3D; edge[i].to;5051 if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge[i].cost)&#123;52 dis[v] &#x3D; dis[u] + edge[i].cost;53 pre[v] &#x3D; i;54 if(!vis[v])&#123;55 vis[v] &#x3D; true;56 q.push(v);57 &#125;58 &#125;59 &#125;60 &#125;61 if(pre[t] &#x3D;&#x3D; -1)return false;62 else return true;63&#125;64int minCostMaxflow(int s, int t, int &amp;cost)&#123;65 int flow &#x3D; 0;66 cost &#x3D; 0;67 while(spfa(s, t))&#123;68 int Min &#x3D; inf;69 for(int i &#x3D; pre[t]; i !&#x3D; -1; i &#x3D; pre[edge[i^1].to])&#123;70 if(Min &gt; edge[i].cap - edge[i].flow)71 Min &#x3D; edge[i].cap - edge[i].flow;72 &#125;73 for(int i &#x3D; pre[t]; i !&#x3D; -1; i &#x3D; pre[edge[i^1].to])&#123;74 edge[i].flow +&#x3D; Min;75 edge[i^1].flow -&#x3D; Min;76 cost +&#x3D; edge[i].cost * Min;77 &#125;78 flow +&#x3D; Min;79 &#125;80 return flow;81&#125;82int a[105];83int main()84&#123;85 int n, sum &#x3D; 0;86 scanf(&quot;%d&quot;, &amp;n);87 init(n + 2);88 go(i,1,n)scanf(&quot;%d&quot;, &amp;a[i]), sum +&#x3D; a[i];89 sum &#x2F;&#x3D; n;90 go(i,1,n)&#123;91 if(a[i] &gt; sum)addedge(0, i, a[i] - sum, 0);92 else addedge(i, n + 1, sum - a[i], 0);93 &#125;94 go(i,1,n-1)addedge(i,i+1,inf,1),addedge(i+1,i,inf,1);95 addedge(1,n,inf,1),addedge(n,1,inf,1);96 int ans;97 minCostMaxflow(0,n+1,ans);98 printf(&quot;%d\\n&quot;, ans);99 return 0;100&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"最大流","slug":"最大流","date":"2020-03-07T09:11:35.941Z","updated":"2020-03-07T09:11:55.262Z","comments":true,"path":"2020/03/07/最大流/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%9C%80%E5%A4%A7%E6%B5%81/","excerpt":"最大流的总结","text":"最大流的总结 P2756 飞行员配对方案问题(最大流)题目链接https://www.luogu.org/problem/P2756 解题思路分源点、汇点，源点连英国飞行员点（流量为1）、每个英国飞行员点连可配合的外籍飞行员点（流量为1）、每个外籍飞行员点连汇点（流量为1），跑最大流即可。 AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2#define go(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)3#define dip(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)4#define maxn 20105#define maxm 12000106#define inf 0x3f3f3f3f7using namespace std;8struct Edge&#123;9 int to, nex, cap, flow;10&#125;edge[maxm];11int tol;12int head[maxn];13void init()&#123;14 tol &#x3D; 2;15 memset(head, -1, sizeof(head));16&#125;17void addedge(int u, int v, int w, int rw &#x3D; 0)&#123;18 edge[tol].to &#x3D; v; edge[tol].cap &#x3D; w; edge[tol].flow &#x3D; 0;19 edge[tol].nex &#x3D; head[u]; head[u] &#x3D; tol++;20 edge[tol].to &#x3D; u; edge[tol].cap &#x3D; rw; edge[tol].flow &#x3D; 0;21 edge[tol].nex &#x3D; head[v]; head[v] &#x3D; tol++;22&#125;23int Q[maxn];24int dep[maxn], cur[maxn], sta[maxn];25bool bfs(int s, int t, int n)&#123;26 int fro &#x3D; 0, tail &#x3D; 0;27 memset(dep, -1, sizeof(dep[0]) * (n + 1));28 dep[s] &#x3D; 0;29 Q[tail++] &#x3D; s;30 while(fro &lt; tail)&#123;31 int u &#x3D; Q[fro++];32 for(int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; edge[i].nex)&#123;33 int v &#x3D; edge[i].to;34 if(edge[i].cap &gt; edge[i].flow &amp;&amp; dep[v] &#x3D;&#x3D; -1)&#123;35 dep[v] &#x3D; dep[u] + 1;36 if(v &#x3D;&#x3D; t)&#123;return true;&#125;37 Q[tail++] &#x3D; v;38 &#125;39 &#125;40 &#125;41 return false;42&#125;43int dinic(int s, int t, int n)&#123;44 int maxflow &#x3D; 0;45 while(bfs(s, t, n))&#123;46 for(int i &#x3D; 0; i &lt; n; i++)cur[i] &#x3D; head[i];47 int u &#x3D; s, tail &#x3D; 0;48 while(cur[s] !&#x3D; -1)&#123;49 if(u &#x3D;&#x3D; t)&#123;50 int tp &#x3D; inf;51 for(int i &#x3D; tail - 1; i &gt;&#x3D; 0; i--)52 tp &#x3D; min(tp, edge[sta[i]].cap - edge[sta[i]].flow);53 maxflow +&#x3D; tp;54 for(int i &#x3D; tail - 1; i &gt;&#x3D; 0; i--)&#123;55 edge[sta[i]].flow +&#x3D; tp;56 edge[sta[i]^1].flow -&#x3D; tp;57 if(edge[sta[i]].cap-edge[sta[i]].flow &#x3D;&#x3D; 0)tail &#x3D; i;58 &#125;59 u &#x3D; edge[sta[tail]^1].to;60 &#125;61 else if(cur[u] !&#x3D; -1 &amp;&amp; edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp; dep[u] + 1 &#x3D;&#x3D; dep[edge[cur[u]].to])&#123;62 sta[tail++] &#x3D; cur[u];63 u &#x3D; edge[cur[u]].to;64 &#125;65 else &#123;66 while(u !&#x3D; s &amp;&amp; cur[u] &#x3D;&#x3D; -1)67 u &#x3D; edge[sta[--tail]^1].to;68 cur[u] &#x3D; edge[cur[u]].nex;69 &#125;70 &#125;71 &#125;72 return maxflow;73&#125;74int main()75&#123;76 int n, m, u, v;77 scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;u, &amp;v);78 init();79 while(u !&#x3D; -1 &amp;&amp; v !&#x3D; -1)&#123;80 addedge(u, v + n, 1);81 scanf(&quot;%d %d&quot;, &amp;u, &amp;v);82 &#125;83 go(i,1,n)addedge(0, i, 1);84 go(i,1,m)addedge(i + n, n + m + 1, 1);85 int ans &#x3D; dinic(0, n + m + 1, n + m + 2);86 if(!ans)&#123;printf(&quot;No Solution!\\n&quot;); return 0;&#125;87 printf(&quot;%d\\n&quot;, ans);88 go(i,1,n)&#123;89 for(int j &#x3D; head[i]; j !&#x3D; -1; j &#x3D; edge[j].nex)&#123;90 if(edge[j].flow &#x3D;&#x3D; 1)printf(&quot;%d %d\\n&quot;, i, edge[j].to - n);91 &#125;92 &#125;93 return 0;94&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"主席树&莫队","slug":"主席树&莫队","date":"2020-03-07T09:10:29.269Z","updated":"2020-03-07T09:11:21.814Z","comments":true,"path":"2020/03/07/主席树&莫队/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E4%B8%BB%E5%B8%AD%E6%A0%91&%E8%8E%AB%E9%98%9F/","excerpt":"主席树&amp;莫队的总结","text":"主席树&amp;莫队的总结 题目传送门：SPOJ-DQUERY D-query（主席树 | 莫队 &amp;&amp; 区间内不同数个数）题目大意：求区间内不同数的个数。 解题思路：主席树做法： 倒序（从右向左）建立主席树，如果一个值还没出现过，则直接插入，否则删除后再重新插入（相当于保留这个数最左出现的位置）。之后要查询 [l, r] 时，选用 l 位置的主席树，这时树中的数据是 [l, n] 范围内的，因此查询时需要传入 r 作为挡板，仅统计小于等于 r 的个数，这样就可以实现 [l, r] 区间不同数的查询。 莫队做法： 莫队模板题 AC代码：主席树：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4using namespace std;5const int MAXN &#x3D; 100001;6struct node7&#123;8 int sum, l, r;9&#125; hjt[MAXN * 40];10int a[MAXN], sorted[MAXN], num;11int root[MAXN], cnt;12int GetIdx(int v)13&#123;14 return lower_bound(sorted + 1, sorted + 1 + num, v) - sorted;15&#125;16void init()17&#123;18 cnt &#x3D; 0;19&#125;20int CreateNode(int sum, int l, int r)21&#123;22 int idx &#x3D; ++cnt;23 hjt[idx].sum &#x3D; sum;24 hjt[idx].l &#x3D; l;25 hjt[idx].r &#x3D; r;26 return idx;27&#125;28void Insert(int &amp;root, int pre_rt, int pos, int l, int r)29&#123;30 root &#x3D; CreateNode(hjt[pre_rt].sum + 1, hjt[pre_rt].l, hjt[pre_rt].r);31 if(l &#x3D;&#x3D; r)return ;32 int m &#x3D; (l + r) &gt;&gt; 1;33 if(pos &lt;&#x3D; m)Insert(hjt[root].l, hjt[pre_rt].l, pos, l, m);34 else Insert(hjt[root].r, hjt[pre_rt].r, pos, m + 1, r);35&#125;36int Query(int s, int e, int k, int l, int r)37&#123;38 if(l &#x3D;&#x3D; r)return l;39 int m &#x3D; (l + r) &gt;&gt; 1;40 int sum &#x3D; hjt[hjt[e].l].sum - hjt[hjt[s].l].sum;41 if(k &lt;&#x3D; sum)return Query(hjt[s].l, hjt[e].l, k, l, m);42 else Query(hjt[s].r, hjt[e].r, k - sum, m + 1, r);43&#125;44int main()45&#123;46 int n, m, i, j, k, l, r;47 while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) !&#x3D; EOF)&#123;48 init();49 for(i &#x3D; 1; i &lt;&#x3D; n; i++)50 &#123;51 scanf(&quot;%d&quot;, &amp;a[i]);52 sorted[i] &#x3D; a[i];53 &#125;54 sort(sorted + 1, sorted + 1 + n);55 num &#x3D; unique(sorted + 1, sorted + 1 + n) - (sorted + 1);56 for(int i &#x3D; 1; i &lt;&#x3D; n; i++)57 &#123;58 Insert(root[i], root[i - 1], GetIdx(a[i]), 1, num);59 &#125;60 while(m--)61 &#123;62 scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k);63 printf(&quot;%d\\n&quot;, sorted[Query(root[l - 1], root[r], k, 1, num)]);64 &#125;65 &#125;66 return 0;67&#125; 莫队：1#include &lt;iostream&gt;2#include &lt;bits&#x2F;stdc++.h&gt;3using namespace std;4int num[1000010],vis[1000010],s[1000010];5int m,block,ans;6struct node7&#123;8 int l,r,id;9 bool operator &lt; (const node &amp;c)const&#123;10 if(l&#x2F;block&#x3D;&#x3D;c.l&#x2F;block)11 return r&lt;c.r;12 return l&#x2F;block &lt; c.l&#x2F;block;13 &#125;14&#125;q[1000010];15161718void add(int x)19&#123;20 vis[s[x]]++;21 if(vis[s[x]]&#x3D;&#x3D;1)ans++;22&#125;2324void del(int x)25&#123;26 vis[s[x]]--;27 if(vis[s[x]]&#x3D;&#x3D;0)ans--;28&#125;2930int main()31&#123;32 int n;33 scanf(&quot;%d&quot;,&amp;n);34 block&#x3D;sqrt(n);35 for(int i&#x3D;1;i&lt;&#x3D;n;i++)36 &#123;37 scanf(&quot;%d&quot;,&amp;s[i]);38 &#125;39 scanf(&quot;%d&quot;,&amp;m);40 for(int i&#x3D;1;i&lt;&#x3D;m;i++)41 &#123;42 scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);43 q[i].id&#x3D;i;44 &#125;45 sort(q+1,q+1+m);46 int l&#x3D;1,r&#x3D;0;47 for(int i&#x3D;1;i&lt;&#x3D;m;i++)48 &#123;49 while(l&lt;q[i].l)del(l),l++;50 while(l&gt;q[i].l)l--,add(l);51 while(r&lt;q[i].r)r++,add(r);52 while(r&gt;q[i].r)del(r),r--;53 num[q[i].id]&#x3D;ans;54 &#125;55 for(int i&#x3D;1;i&lt;&#x3D;m;i++)56 &#123;57 printf(&quot;%d\\n&quot;,num[i]);58 &#125;59 return 0;60&#125; 题目传送门：POJ-2104 K-th Number（主席树 &amp;&amp; 区间第 k 大）题目大意：求区间第 k 小的数。 解题思路：主席树模板题 AC代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4using namespace std;5const int MAXN &#x3D; 100001;6struct node7&#123;8 int sum, l, r;9&#125; hjt[MAXN * 40];10int a[MAXN], sorted[MAXN], num;11int root[MAXN], cnt;12int GetIdx(int v)13&#123;14 return lower_bound(sorted + 1, sorted + 1 + num, v) - sorted;15&#125;16void init()17&#123;18 cnt &#x3D; 0;19&#125;20int CreateNode(int sum, int l, int r)21&#123;22 int idx &#x3D; ++cnt;23 hjt[idx].sum &#x3D; sum;24 hjt[idx].l &#x3D; l;25 hjt[idx].r &#x3D; r;26 return idx;27&#125;28void Insert(int &amp;root, int pre_rt, int pos, int l, int r)29&#123;30 root &#x3D; CreateNode(hjt[pre_rt].sum + 1, hjt[pre_rt].l, hjt[pre_rt].r);31 if(l &#x3D;&#x3D; r)return ;32 int m &#x3D; (l + r) &gt;&gt; 1;33 if(pos &lt;&#x3D; m)Insert(hjt[root].l, hjt[pre_rt].l, pos, l, m);34 else Insert(hjt[root].r, hjt[pre_rt].r, pos, m + 1, r);35&#125;36int Query(int s, int e, int k, int l, int r)37&#123;38 if(l &#x3D;&#x3D; r)return l;39 int m &#x3D; (l + r) &gt;&gt; 1;40 int sum &#x3D; hjt[hjt[e].l].sum - hjt[hjt[s].l].sum;41 if(k &lt;&#x3D; sum)return Query(hjt[s].l, hjt[e].l, k, l, m);42 else Query(hjt[s].r, hjt[e].r, k - sum, m + 1, r);43&#125;44int main()45&#123;46 int n, m, i, j, k, l, r;47 while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) !&#x3D; EOF)&#123;48 init();49 for(i &#x3D; 1; i &lt;&#x3D; n; i++)50 &#123;51 scanf(&quot;%d&quot;, &amp;a[i]);52 sorted[i] &#x3D; a[i];53 &#125;54 sort(sorted + 1, sorted + 1 + n);55 num &#x3D; unique(sorted + 1, sorted + 1 + n) - (sorted + 1);56 for(int i &#x3D; 1; i &lt;&#x3D; n; i++)57 &#123;58 Insert(root[i], root[i - 1], GetIdx(a[i]), 1, num);59 &#125;60 while(m--)61 &#123;62 scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k);63 printf(&quot;%d\\n&quot;, sorted[Query(root[l - 1], root[r], k, 1, num)]);64 &#125;65 &#125;66 return 0;67&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"种类并查集","slug":"种类并查集","date":"2020-03-07T09:09:38.077Z","updated":"2020-03-07T09:10:17.453Z","comments":true,"path":"2020/03/07/种类并查集/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"种类并查集的总结","text":"种类并查集的总结 POJ - 1703 Find them, Catch them (种类并查集)1#include &lt;algorithm&gt;2#include &lt;iostream&gt;3#include &lt;cstring&gt;4#include &lt;cstdio&gt;5using namespace std;6int pre[300000];7int fin(int a)8&#123;9 if (pre[a]==a) return a;10 int t=a;11 while (pre[a]!=a)12 &#123;13 a=pre[a];14 &#125;15 while (pre[t]!=t)16 &#123;17 int t2=t;18 t=pre[t];19 pre[t2]=a;20 &#125;21 return a;22&#125;23int sam(int x, int y)24&#123;25 return fin(x) == fin(y);26&#125;27void join(int x, int y)28&#123;29 int a = fin(x), b = fin(y);30 if(a != b)pre[a] = b;31&#125;32int main()33&#123;34 std::ios::sync_with_stdio(0);35 int n, m, i, sum = 0, a1, a2;36 scanf(\"%d\", &amp;sum);37 while(sum--)38 &#123;39 scanf(\"%d %d\", &amp;n, &amp;m);40 char cmd[15];41 for(i = 1; i &lt;= 2 * n; i++)pre[i] = i;42 for(i = 1; i &lt;= m; i++)43 &#123;44 getchar();45 scanf(\"%s %d %d\", &amp;cmd, &amp;a1, &amp;a2);46 if(strcmp(cmd, \"A\") == 0)47 &#123;48 if(sam(a1, a2 + n) || sam(a2, a1 + n))printf(\"In different gangs.\\n\");49 else if(sam(a1, a2) || sam(a1 + n, a2 + n))50 &#123;51 join(a1, a2);52 join(a1 + n, a2 + n);53 printf(\"In the same gang.\\n\");54 &#125;55 else printf(\"Not sure yet.\\n\");56 &#125;57 else58 &#123;59 join(a1,a2 + n);60 join(a2, a1 + n);61 &#125;62 &#125;63 &#125;64 return 0;65&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"斜率DP","slug":"斜率DP","date":"2020-03-07T09:08:35.252Z","updated":"2020-03-07T09:09:24.246Z","comments":true,"path":"2020/03/07/斜率DP/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%96%9C%E7%8E%87DP/","excerpt":"斜率DP的总结","text":"斜率DP的总结 斜率DP用来优化一类形如 dp[i]=min(dp[j]+f(i,j))dp[i]=min(dp[j]+f(i,j)) 的动态规划问题 从HDU3507入手题目大意将长度为 nn 的数组划分成若干段，每段的花费为这段数字和的平方加 MM,求最小花费。 DP解法定义 dp[i]dp[i] 为到i为止划分为若干段的最小花费，则有转移方程： dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i)dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i) 可以发现复杂度为n2n2的。 优化方法 设 k&lt;j&lt;ik&lt;j&lt;i 若 jj 转移至 ii 比 kk 转移至 ii 更优(本题中为 jj 转移至 ii 花费更小) 则有 dp[j]+M+(sum[i]−sum[j])2&lt;dp[k]+M+(sum[i]−sum[k])2dp[j]+M+(sum[i]−sum[j])2&lt;dp[k]+M+(sum[i]−sum[k])2 移项化简得 (dp[j]+sum[j]2)−(dp[k]+sum[k]2)2sum[j]−2sum[k]&lt;sumi−(dp[k]+sum[k]2)2sum[j]−2sum[k]&lt;sum[i] 设Y(x)=dp[x]+sum[x]2Y(x)=dp[x]+sum[x]2,X(x)=2sum[x]X(x)=2sum[x],g[i,j]=Y(i)−Y(j)X(i)−X(j)g[i,j]=Y(i)−Y(j)X(i)−X(j) 则有当g[j,k]&lt;sum[i]g[j,k]&lt;sum[i]时，jj转移至ii要比kk转移至ii更优 分析当g[i,j]&lt;g[j,k]g[i,j]&lt;g[j,k]时，若g[i,j]&lt;sum[i]g[i,j]&lt;sum[i],则ii比jj优，若g[i,j]&gt;=sum[i]g[i,j]&gt;=sum[i],则g[j,k]&gt;sum[i]g[j,k]&gt;sum[i]，即jj不如kk优 结论:对于ii点当g[j,k]&lt;g[i,j]g[j,k]&lt;g[i,j]时，jj必然不是最优的转移方案 用单调队列维护有效解集，则有效解集的斜率为递增的 随着i的增长，sum[i]sum[i]单调递增，因此若对于一个jj为ii的最优转移方案，则对于ii之后的任意一点，jj之前的点一定不如jj优。 那么对于新入队的元素ii，若队尾元素与ii的斜率小于队尾元素与上一个元素的斜率，则不断删除队尾元素，直至单调 对于每次转移，找到第一个斜率大于sum[i]sum[i]的点jj，从那jj点转移，并将jj点前的元素出队 算法复杂度为O(n)O(n) AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3#define ll long long4#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)5#define N 5000056#define p2(x) (x)*(x)7ll a[N],dp[N],n,m,head,tail,q[N],sum[N];8ll getdp(ll i,ll j)&#123;return dp[j]+m+p2(sum[i]-sum[j]);&#125;9ll getup(ll i,ll j)&#123;return dp[i]+p2(sum[i])-(dp[j]+p2(sum[j]));&#125;10ll getdown(ll i,ll j)&#123;return 2ll*(sum[i]-sum[j]);&#125;11void init()&#123;12 head&#x3D;tail&#x3D;dp[0]&#x3D;sum[0]&#x3D;0;13 q[tail++]&#x3D;0;14&#125;15int main()16&#123;17 while(cin&gt;&gt;n&gt;&gt;m)&#123;18 go(i,1,n)scanf(&quot;%lld&quot;,&amp;a[i]),sum[i]&#x3D;sum[i-1]+a[i];19 init();20 go(i,1,n)&#123;21 while(head+1&lt;tail&amp;&amp;getup(q[head],q[head+1])&gt;sum[i]*getdown(q[head],q[head]+1))head++;22 dp[i]&#x3D;getdp(i,q[head]);23 while(head+1&lt;tail&amp;&amp;getdown(q[tail-1],q[tail-2])*getup(i,q[tail-1])&lt;&#x3D;getdown(i,q[tail-1])*getup(q[tail-1],q[tail-2]))tail--;24 q[tail++]&#x3D;i;25 &#125;26 printf(&quot;%lld\\n&quot;,dp[n]);27 &#125;28 return 0;29&#125; HDU3507链接http://acm.hdu.edu.cn/showproblem.php?pid=3507 备注dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i)dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i)+斜率优化，入门题 AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3#define ll long long4#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)5#define N 5000056#define p2(x) (x)*(x)7ll a[N],dp[N],n,m,head,tail,q[N],sum[N];8ll getdp(ll i,ll j)&#123;return dp[j]+m+p2(sum[i]-sum[j]);&#125;9ll getup(ll i,ll j)&#123;return dp[i]+p2(sum[i])-(dp[j]+p2(sum[j]));&#125;10ll getdown(ll i,ll j)&#123;return 2ll*(sum[i]-sum[j]);&#125;11void init()&#123;12 head&#x3D;tail&#x3D;dp[0]&#x3D;sum[0]&#x3D;0;13 q[tail++]&#x3D;0;14&#125;15int main()16&#123;17 while(cin&gt;&gt;n&gt;&gt;m)&#123;18 go(i,1,n)scanf(&quot;%lld&quot;,&amp;a[i]),sum[i]&#x3D;sum[i-1]+a[i];19 init();20 go(i,1,n)&#123;21 while(head+1&lt;tail&amp;&amp;getup(q[head],q[head+1])&gt;sum[i]*getdown(q[head],q[head]+1))head++;22 dp[i]&#x3D;getdp(i,q[head]);23 while(head+1&lt;tail&amp;&amp;getdown(q[tail-1],q[tail-2])*getup(i,q[tail-1])&lt;&#x3D;getdown(i,q[tail-1])*getup(q[tail-1],q[tail-2]))tail--;24 q[tail++]&#x3D;i;25 &#125;26 printf(&quot;%lld\\n&quot;,dp[n]);27 &#125;28 return 0;29&#125; BZOJ1010链接https://www.lydsy.com/JudgeOnline/problem.php?id=1010 备注dp[i]=min{dp[j]+(sum[i]−sum[j]+i−j−1−L)2}dp[i]=min{dp[j]+(sum[i]−sum[j]+i−j−1−L)2}，思路为将括号里的内容分为两个函数，便于展开。打错了函数名，调了一上午。。。 AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3#define ll long long4#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)5#define N 5000056#define p2(x) (x)*(x)7ll a[N],sum[N],tail,head,q[N],L,n,m,dp[N];8void init()&#123;head&#x3D;tail&#x3D;sum[0]&#x3D;dp[0]&#x3D;0;q[tail++]&#x3D;0;&#125;9ll getx(ll x)&#123;return x+sum[x];&#125;10ll gety(ll x)&#123;return x+sum[x]+1+L;&#125;11ll getdp(ll i,ll j)&#123;return dp[j]+p2(getx(i)-gety(j));&#125;12ll getup(ll j,ll k)&#123;return (dp[j]+p2(gety(j)))-(dp[k]+p2(gety(k)));&#125;13ll getdown(ll j,ll k)&#123;return 2ll*(gety(j)-gety(k));&#125;14int main()15&#123;16 cin&gt;&gt;n&gt;&gt;L;17 init();18 go(i,1,n)scanf(&quot;%lld&quot;,&amp;a[i]),sum[i]&#x3D;sum[i-1]+a[i];19 go(i,1,n)&#123;20 while(head+1&lt;tail&amp;&amp;getup(q[head+1],q[head])&lt;getx(i)*getdown(q[head+1],q[head]))head++;21 dp[i]&#x3D;getdp(i,q[head]);22 while(head+1&lt;tail&amp;&amp;getup(i,q[tail-1])*getdown(q[tail-1],q[tail-2])&lt;getup(q[tail-1],q[tail-2])*getdown(i,q[tail-1]))tail--;23 q[tail++]&#x3D;i;24 &#125;25 printf(&quot;%lld\\n&quot;,dp[n]);26 return 0;27&#125; 牛客2019多校十J题目大意给定n块木板长与高，要求分为k组，每组经过切割变为等高，切割部分不能再利用，求最小浪费面积 分析 将n块木板按从高到低排序，则每组木板必是连续的一段区间，且统一高度为该组中高度最小的木板高度。 求最小浪费面积即是求最大剩余面积 DP方程dp[k][i]=maxdp[k−1][j]+h[j]∗(sum[i]−sum[j])dp[k][i]=maxdp[k−1][j]+h[j]∗(sum[i]−sum[j]) 备注 二维斜率dp类似背包，可以倒着跑开一维或正着跑开二维 每维开一个单调队列，用上一组单调队列转移，新元素添加至本组 注意整数范围，过程爆long long,使用 __int128 AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3#define ll long long4#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)5#define N 50056#define lll __int1287#define p2(x) (x)*(x)8struct node&#123;9 ll a,b;10 bool operator&lt;(const node &amp;x)const&#123;11 return a&gt;x.a;12 &#125;13&#125;s[N];14ll dp[N][N],sum[N],head[N],tail[N],q[N][N],n,m;15ll getdp(ll i,ll j,ll y)&#123;return dp[y-1][j]+s[i].a*(sum[i]-sum[j]);&#125;16ll gety(ll i,ll y)&#123;return (dp[y-1][i]);&#125;17ll getup(ll j,ll k,ll y)&#123;return gety(j,y)-gety(k,y);&#125;18ll getdown(ll j,ll k)&#123;return sum[j]-sum[k];&#125;19ll getx(ll i)&#123;return s[i].a;&#125;20int main()21&#123;22 scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);ll sum1&#x3D;0;23 go(i,1,n)scanf(&quot;%lld%lld&quot;,&amp;s[i].b,&amp;s[i].a),sum1+&#x3D;s[i].b*s[i].a;24 sort(s+1,s+1+n);25 go(i,1,n)sum[i]&#x3D;sum[i-1]+s[i].b;26 go(i,0,m-1)head[i]&#x3D;tail[i]&#x3D;0,q[i][tail[i]++]&#x3D;0;27 go(j,1,m)&#123;28 go(i,1,n)&#123;29 while(head[j-1]+1&lt;tail[j-1]&amp;&amp;30 (lll)getup(q[j-1][head[j-1]+1],q[j-1][head[j-1]],j)31 &gt;(lll)getx(i)*(lll)getdown(q[j-1][head[j-1]+1],q[j-1][head[j-1]]))32 head[j-1]++;33 dp[j][i]&#x3D;getdp(i,q[j-1][head[j-1]],j);34 while(head[j]+1&lt;tail[j]&amp;&amp;35 (lll)getup(i,q[j][tail[j]-1],j+1)36 *(lll)getdown(q[j][tail[j]-1],q[j][tail[j]-2])37 &gt;(lll)getup(q[j][tail[j]-1],q[j][tail[j]-2],j+1)38 *(lll)getdown(i,q[j][tail[j]-1]))tail[j]--;39 q[j][tail[j]++]&#x3D;i;40 &#125;41 &#125;42 printf(&quot;%lld\\n&quot;,sum1-dp[m][n]);43 return 0;44&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"线性基","slug":"线性基","date":"2020-03-07T09:07:47.349Z","updated":"2020-03-07T09:08:26.585Z","comments":true,"path":"2020/03/07/线性基/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E7%BA%BF%E6%80%A7%E5%9F%BA/","excerpt":"线性基的总结","text":"线性基的总结 线性基详解线性基是什么你可以理解为将一个序列处理完之后得到的产物，并且有如下性质（后面有证明）： 线性基的性质 原序列里面的任意一个数都可以由线性基里面的一些数异或得到 线性基里面的任意一些数异或起来都不能得到00 线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的 线性基的构造过程那么它是怎么构造的呢？ 我们设有一个数组dd，表示序列aa的线性基，下标从00开始算。对于序列里面的每一个数，我们尝试将它插入到线性基里面去，具体如何插入这里给出伪代码（为了方便理解，我们设 x(2)x(2) 为xx的二进制数）： 1复制for i&#x3D;60 to 02if(x(2)的第i+1位为1)3&#123;4 if(d[i]为0)5 &#123;6 d[i]&#x3D;x;7 break;8 &#125;9 else x&#x3D;x^d[i];10&#125; 据此，我们可以得到一个关于dd数组的性质：若d[i]d[i]不为00，则d[i]（2）d[i]（2）的第i+1i+1位为11，并且d[i]（2）d[i]（2）的最高位就是第i+1i+1位。为了更好地进行线性基的讲解，我们要先知道关于异或的一个小性质：如果满足aa ^ bb ^ c=0c=0 ，那么aa ^ b=cb=c，所以如果aa ^ b=cb=c，那么aa ^ c=bc=b证明虽然简单但是这里就不给出了，不明白的读者手动模拟一下就明白了 线性基性质的证明性质1我们知道了线性基的构造方法后，其实就可以很容易想到如何证明性质1了，我们设原序列里面有一个数x，我们尝试用它来构造线性基，那么会有两种结果：1、不能成功插入线性基；2、成功插入线性基。 分类讨论一下： 不能成功插入线性基 什么时候不能插入进去呢？显然就是它在尝试插入时异或若干个数之后变成了00那么就有如下式子：xx ^ d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=0=0根据上面的那个小性质，则有：d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=x=x所以，如果xx不能成功插入线性基，一定是因为当前线性基里面的一些数异或起来可以等于xx。 可以成功插入线性基 我们假设xx插入到了线性基的第ii个位置，显然，它在插入前可能异或若干个数，那么就有：xx ^ d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=d[i]=d[i]d[i]d[i] ^ d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=x=x所以显然，xx此时也可以由线性基里面的若干个数异或得到。 综上，性质1得证 性质2我们使用反证法设d[a]d[a] ^ d[b]d[b] ^ d[c]=0d[c]=0（其中d[c]d[c]比d[a]d[a]和d[b]d[b]要更晚被插入线性基）那么有d[a]d[a] ^ d[b]=d[c]d[b]=d[c]∵d[c]∵d[c]可以由d[a]d[a] ^ d[b]d[b]得到∴d[c]∴d[c]不可能插入线性基故假设不成立，所以线性基中不存在有任何数异或起来可以得到00。 性质3分类讨论一下 假如序列里面的所有元素都可以插入到线性基里面 显然如果是这种情况的话，不管是用什么顺序将序列里的数插入到线性基里，线性基中的元素一定与原序列元素数量相同。所以性质3成立。 假如序列里面的一些元素不能插入到线性基里面 我们设xx不能插入到线性基里面，那么一定满足形如d[a]d[a] ^ d[b]d[b] ^ d[c]=xd[c]=x的式子，那我们尝试将插入顺序改变，变成：d[a]d[a]、d[b]d[b]、xx、d[c]d[c]。那么显然，d[c]d[c]是不可能插入成功的，简单的证明：∵d[a]∵d[a] ^ d[b]d[b] ^ d[c]=xd[c]=x∴d[a]∴d[a] ^ d[b]d[b] ^ x=d[c]x=d[c]（根据上面那条异或性质）原来是xx插入不进去，改变顺序后，d[c]d[c]插入不进去，也就是说，对于插入不进去的元素，改变插入顺序后，要么还是插入不进去，要么就是插入进去了，同时另一个原来插入的进去的元素插入不进去了，所以，可以插入进去的元素数量一定是固定的。显然，如果你去掉线性基里面的任意一个数，都会使得原序列里的一些（或一个）数无法通过用线性基里的元素异或得到，所以，每一个元素都是必要的，换句话说，这里面没有多余的元素，所以，这个线性基的元素个数在保持性质1的前提下，一定是最少的。 模板1复制void add(ll x)2&#123;3 for(int i&#x3D;50;i&gt;&#x3D;0;i--)4 &#123;5 if(x&amp;(1ll&lt;&lt;i))&#x2F;&#x2F;注意，如果i大于31，前面的1的后面一定要加ll6 &#123;7 if(d[i])x^&#x3D;d[i];8 else9 &#123;10 d[i]&#x3D;x;11 break;&#x2F;&#x2F;记得如果插入成功一定要退出12 &#125;13 &#125;14 &#125;15&#125; 线性基的应用求异或最大值1复制ll ans()2&#123;3 ll anss&#x3D;0;4 for(int i&#x3D;50;i&gt;&#x3D;0;i--)&#x2F;&#x2F;记得从线性基的最高位开始5 if((anss^d[i])&gt;anss)anss^&#x3D;d[i];6 return anss;7 &#125; 求异或最小值显然的，最小值一定是最小的d[i]d[i] 求异或第 K 小值完整的说，应该是——从一个序列中取任意个元素进行异或，求能异或出的所有数字中第kk小的那个。首先，要对这个序列的线性基处理一下，对于每一个d[i]d[i]，枚举j=ito1j=ito1，如果d[i]（2）d[i]（2）的第jj位为11，那么d[i]d[i]异或d[j−1]d[j−1]。那么处理完一个线性基之后，应该大致是长这个样子的（x表示0或1）：1xxxx0xxx0x1xxxx0xxx0x……1xxx0x……1xxx0x………..1x………..1x求解过程：将k先转成二进制，假如kk的第ii位为11，ansans就异或上线性基中第ii个元素（注意不是直接异或d[i−1]d[i−1]）。 1复制void work()&#x2F;&#x2F;处理线性基2&#123;3 for(int i&#x3D;1;i&lt;&#x3D;60;i++)4 for(int j&#x3D;1;j&lt;&#x3D;i;j++)5 if(d[i]&amp;(1&lt;&lt;(j-1)))d[i]^&#x3D;d[j-1];6&#125;7ll k_th(ll k)8&#123;9 if(k&#x3D;&#x3D;1&amp;&amp;tot&lt;n)return 0;&#x2F;&#x2F;特判一下，假如k&#x3D;1，并且原来的序列可以异或出0，就要返回0，tot表示线性基中的元素个数，n表示序列长度10 if(tot&lt;n)k--;&#x2F;&#x2F;类似上面，去掉0的情况，因为线性基中只能异或出不为0的解11 work();12 ll ans&#x3D;0;13 for(int i&#x3D;0;i&lt;&#x3D;60;i++)14 if(d[i]!&#x3D;0)15 &#123;16 if(k%2&#x3D;&#x3D;1)ans^&#x3D;d[i];17 k&#x2F;&#x3D;2;18 &#125;19&#125; 判断能否被当前线性基中元素异或得到把它尝试插入进线性基里面去，假如可以插入，说明不能异或得到，假如插不进去，说明能异或得到 题集P3812 【模板】线性基“https://www.luogu.org/problem/P3812&quot; P4570 [BJWC2011]元素“https://www.luogu.org/problem/P4570&quot; P3857 [TJOI2008]彩灯“https://www.luogu.org/problem/P3857&quot; P3292 [SCOI2016]幸运数字“https://www.luogu.org/problem/P3292&quot; 参考博客“https://blog.csdn.net/a_forever_dream/article/details/83654397&quot;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"线段树","slug":"线段树","date":"2020-03-07T09:07:10.299Z","updated":"2020-03-07T09:07:40.155Z","comments":true,"path":"2020/03/07/线段树/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"线段树的总结","text":"线段树的总结 HYSBZ - 1012 最大数maxnumber (线段树)1#include &lt;bits/stdc++.h&gt;2#define ll long long3#define maxn 2000054using namespace std;5struct node6&#123;7 ll left, right;8 ll maxx;9&#125;;10node tree[maxn &lt;&lt; 2];11ll a[maxn] = &#123;0&#125;;12ll n;13ll p = 0, q;14void build(int m, int l, int r)15&#123;16 tree[m].left = l;17 tree[m].right = r;18 if (l == r)&#123;19 tree[m].maxx = a[l];20 return;21 &#125;22 int mid = (l + r) &gt;&gt; 1;23 build(m &lt;&lt; 1, l, mid);24 build(m &lt;&lt; 1 | 1, mid + 1, r);25 tree[m].maxx = max(tree[m &lt;&lt; 1].maxx, tree[m &lt;&lt; 1 | 1].maxx);26&#125;27void update(int m, int a, int val)28&#123;29 if (tree[m].left == a &amp;&amp; tree[m].right == a)&#123;30 tree[m].maxx += val;31 return;32 &#125;33 int mid = (tree[m].left + tree[m].right) &gt;&gt; 1;34 if (a &lt;= mid)&#123;35 update(m &lt;&lt; 1, a, val);36 &#125;37 else&#123;38 update(m &lt;&lt; 1 | 1, a, val);39 &#125;40 tree[m].maxx = max(tree[m &lt;&lt; 1].maxx, tree[m &lt;&lt; 1 | 1].maxx);41&#125;42ll queryMax(int m, int l, int r)43&#123;44 if (l == tree[m].left &amp;&amp; r == tree[m].right)&#123;45 return tree[m].maxx;46 &#125;47 int mid = (tree[m].left + tree[m].right) &gt;&gt; 1;48 if (r &lt;= mid)&#123;49 return queryMax(m &lt;&lt; 1, l, r);50 &#125;51 else if (l &gt; mid)&#123;52 return queryMax(m &lt;&lt; 1 | 1, l, r);53 &#125;54 return max(queryMax(m &lt;&lt; 1, l, mid), queryMax(m &lt;&lt; 1 | 1, mid + 1, r));55&#125;56int main()57&#123;58 ll t = 0,i,j, k, MOD, l;59 char cmd;60 scanf(\"%lld %lld\", &amp;n, &amp;MOD);61 build(1, 1, n);62 for(k = 1; k &lt;= n; k++)63 &#123;64 getchar();65 scanf(\"%c %lld\", &amp;cmd, &amp;l);66 if(cmd == 'Q')67 &#123;68 //cout &lt;&lt; p - l + 1 &lt;&lt; \" \" &lt;&lt; p &lt;&lt; endl;69 t = queryMax(1, p - l + 1,p);70 printf(\"%lld\\n\", t);71 &#125;72 else73 &#123;74 update(1, p + 1, (l + t) % MOD);75 p++;76 &#125;77 &#125;78 return 0;79&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"拓扑排序","slug":"拓扑排序","date":"2020-03-07T09:06:14.470Z","updated":"2020-03-07T09:07:00.722Z","comments":true,"path":"2020/03/07/拓扑排序/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","excerpt":"拓扑排序的总结","text":"拓扑排序的总结 题目传送门：POJ-2367 Genealogical tree题目大意：给定一个有向无环图，求拓扑排序序列 解题思路：拓扑排序模板题 AC代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4using namespace std;5const int maxn &#x3D; 100010;6int head[maxn], links, ans[maxn], pi, n, in[maxn], vis[maxn];7struct node8&#123;9 int v, nex;10&#125;edge[maxn];11void init()12&#123;13 memset(head, 0, sizeof(head));14 memset(in, 0, sizeof(in));15 memset(vis, 0, sizeof(vis));16 links &#x3D; 0;17 pi &#x3D; 0;18&#125;19void add_edge(int u, int v)20&#123;21 edge[++links].v &#x3D; v;22 edge[links].nex &#x3D; head[u];23 head[u] &#x3D; links;24&#125;25void tsort()26&#123;27 int i, j;28 for(i &#x3D; 1; i &lt;&#x3D; n; i++)29 &#123;30 for(j &#x3D; 1; j &lt;&#x3D; n; j++)31 &#123;32 if(!vis[j] &amp;&amp; !in[j])33 &#123;34 vis[j] &#x3D; 1;35 ans[pi++] &#x3D; j;36 break;37 &#125;38 &#125;39 int u &#x3D; j;40 for(j &#x3D; head[u]; j; j &#x3D; edge[j].nex)41 &#123;42 in[edge[j].v]--;43 &#125;44 &#125;45&#125;46int main()47&#123;48 int m, i, j, k;49 while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)50 &#123;51 init();52 for(i &#x3D; 1; i &lt;&#x3D; n; i++)53 &#123;54 while(1)55 &#123;56 scanf(&quot;%d&quot;, &amp;j);57 if(j &#x3D;&#x3D; 0)break;58 in[j]++;59 add_edge(i, j);60 &#125;61 &#125;62 tsort();63 for(i &#x3D; 0; i &lt; pi; i++)64 &#123;65 if(i !&#x3D; 0)printf(&quot; &quot;);66 printf(&quot;%d&quot;, ans[i]);67 &#125;68 printf(&quot;\\n&quot;);69 &#125;70 return 0;71&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数位DP","slug":"数位DP","date":"2020-03-07T09:03:30.592Z","updated":"2020-03-07T09:04:25.579Z","comments":true,"path":"2020/03/07/数位DP/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%95%B0%E4%BD%8DDP/","excerpt":"数位DP的总结","text":"数位DP的总结 基础：https://blog.csdn.net/Miracle_QSH/article/details/85067535进阶：https://blog.csdn.net/Miracle_QSH/article/details/85079176","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数论四大定理","slug":"数论四大定理","date":"2020-03-07T09:02:31.253Z","updated":"2020-03-07T09:03:18.162Z","comments":true,"path":"2020/03/07/数论四大定理/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%95%B0%E8%AE%BA%E5%9B%9B%E5%A4%A7%E5%AE%9A%E7%90%86/","excerpt":"数论四大定理的总结","text":"数论四大定理的总结 威尔逊定理(p−1)!=p−1(mod**p) 当且仅当p 为质数 威尔逊定理模板题2019 HDU 多校第三场 1006 HDU-6608 欧拉定理若n,a为正整数，且n,a互质，即gcd(a,n)=1，则a ^ φ(n) ≡ 1 (mod n) 孙子定理（中国剩余定理）用现代数学的语言来说明的话，中国剩余定理给出了以下的一元线性同余方程组： 中国剩余定理说明：假设整数m1,m2, … ,mn两两互质，则对任意的整数：a1,a2, … ,an，方程组 &amp;(S)&amp;有解。 并且通解可以用如下方式构造得到： 设M=m_1 \\times m_2 \\times … \\times m_n = \\prod_{i=1}^n{m_i} 是整数m1,m2,… ,mn的乘积，并设M_i = {M \\over m_i}, \\forall i \\in {1,2,…,n}是除了mi以外的n- 1个整数的乘积。设t_i = M_i^-1这个就是逆元了，则t_i M_i=1(mod m_i), \\forall i \\in {1,2,…,n} 通解形式为: 在模M的意义下，方程组(S)只有一个解： 费马小定理若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。 补充费马大定理当整数n &gt;2时，关于x, y, z的方程 x^n + y^n = z^$n￥ 没有正整数解","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"树状数组","slug":"树状数组","date":"2020-03-07T09:01:44.629Z","updated":"2020-03-07T09:02:20.289Z","comments":true,"path":"2020/03/07/树状数组/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"树状数组的总结","text":"树状数组的总结 HDU - 1166 敌兵布阵1#include &lt;bits/stdc++.h&gt;2using namespace std;3int a[50005];4char cmd[1005];5int main()6&#123;7 int t, n, m, i, j, k, ca = 1;8 scanf(\"%d\", &amp;t);9 while(t--)10 &#123;11 scanf(\"%d\", &amp;n);12 for(i = 0; i &lt;= n; i++)a[i] = 0;13 for(i = 1; i &lt;= n; i++)14 &#123;15 scanf(\"%d\", &amp;k);16 for(j = i; j &lt;= n; j += j &amp; -j)a[j] += k;17 &#125;18 printf(\"Case %d:\\n\", ca++);19 while(scanf(\"%s\", cmd) != EOF)20 &#123;21 if(cmd[0] == 'E')break;22 else if(cmd[0] == 'Q')23 &#123;24 int l, r;25 scanf(\"%d %d\", &amp;l, &amp;r);26 int ans1 = 0, ans2 = 0;27 for(i = r; i &gt; 0; i -= i &amp; -i)ans1 += a[i];28 for(i = l - 1; i &gt; 0; i -= i &amp; -i)ans2 += a[i];29 printf(\"%d\\n\", ans1 - ans2);30 &#125;31 else if(cmd[0] == 'A')32 &#123;33 int x, y;34 scanf(\"%d %d\", &amp;x, &amp;y);35 for(;x &lt;= n; x += x &amp; -x)a[x] += y;36 &#125;37 else38 &#123;39 int x, y;40 scanf(\"%d %d\", &amp;x, &amp;y);41 for(;x &lt;= n; x += x &amp; -x)a[x] -= y;42 &#125;43 &#125;44 &#125;45 return 0;46&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"容斥原理","slug":"容斥原理","date":"2020-03-07T09:00:49.253Z","updated":"2020-03-07T09:01:31.472Z","comments":true,"path":"2020/03/07/容斥原理/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","excerpt":"容斥原理的总结","text":"容斥原理的总结 HDU - 1796 How many integers can you find （容斥原理）1#include&lt;bits/stdc++.h&gt;2using namespace std;3typedef long long ll;4ll n, m, a[15], ans, p;5ll lcm(ll a, ll b)&#123;return a * b / __gcd(a, b);&#125;6void dfs(ll x, ll sum, ll num)7&#123;8 if(num &gt; m)return;9 if(num % 2 == 1)&#123;ans += (n - 1) / sum;&#125;10 if(num % 2 == 0)&#123;ans -= (n - 1) / sum;&#125;11 for(ll i = x + 1; i &lt; m; i++)12 &#123;13 dfs(i, lcm(sum, a[i]), num + 1);14 &#125;15 return ;16&#125;17int main()18&#123;19 while(scanf(\"%lld %lld\", &amp;n, &amp;p) != EOF)20 &#123;21 m = 0;22 for(ll i = 0; i &lt; p; i++)23 &#123;24 scanf(\"%lld\", &amp;a[m++]);25 if(a[i] == 0 || a[i] &gt; n)m--;26 &#125;27 ans = 0;28 ll flag = 0;29 for(ll i = 0; i &lt; m; i++)30 &#123;31 dfs(i, a[i], 1);32 if(n % a[i] == 0)flag = 1;33 &#125;34 printf(\"%lld\\n\", ans);35 &#125;36 return 0;37&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"米勒罗宾素数测试","slug":"米勒罗宾素数测试","date":"2020-03-07T09:00:05.667Z","updated":"2020-03-07T09:00:39.535Z","comments":true,"path":"2020/03/07/米勒罗宾素数测试/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E7%B1%B3%E5%8B%92%E7%BD%97%E5%AE%BE%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95/","excerpt":"米勒罗宾素数测试的总结","text":"米勒罗宾素数测试的总结 模板1复制&#x2F;&#x2F; 18位素数：154590409516822759 2&#x2F;&#x2F; 19位素数：2305843009213693951 (梅森素数) 3&#x2F;&#x2F; 19位素数：4384957924686954497 4LL prime[6] &#x3D; &#123;2, 3, 5, 233, 331&#125;; 5LL qmul(LL x, LL y, LL mod) &#123; &#x2F;&#x2F; 乘法防止溢出， 如果p * p不爆LL的话可以直接乘； O(1)乘法或者转化成二进制加法 678 return (x * y - (long long)(x &#x2F; (long double)mod * y + 1e-3) *mod + mod) % mod; 9 &#x2F;*10 LL ret &#x3D; 0;11 while(y) &#123;12 if(y &amp; 1)13 ret &#x3D; (ret + x) % mod;14 x &#x3D; x * 2 % mod;15 y &gt;&gt;&#x3D; 1;16 &#125;17 return ret;18 *&#x2F; 19&#125; 20LL qpow(LL a, LL n, LL mod) &#123; 21 LL ret &#x3D; 1; 22 while(n) &#123; 23 if(n &amp; 1) ret &#x3D; qmul(ret, a, mod); 24 a &#x3D; qmul(a, a, mod); 25 n &gt;&gt;&#x3D; 1; 26 &#125; 27 return ret; 28&#125; 29bool Miller_Rabin(LL p) &#123; 30 if(p &lt; 2) return 0; 31 if(p !&#x3D; 2 &amp;&amp; p % 2 &#x3D;&#x3D; 0) return 0; 32 LL s &#x3D; p - 1; 33 while(! (s &amp; 1)) s &gt;&gt;&#x3D; 1; 34 for(int i &#x3D; 0; i &lt; 5; ++i) &#123; 35 if(p &#x3D;&#x3D; prime[i]) return 1; 36 LL t &#x3D; s, m &#x3D; qpow(prime[i], s, p); 37 while(t !&#x3D; p - 1 &amp;&amp; m !&#x3D; 1 &amp;&amp; m !&#x3D; p - 1) &#123; 38 m &#x3D; qmul(m, m, p); 39 t &lt;&lt;&#x3D; 1; 40 &#125; 41 if(m !&#x3D; p - 1 &amp;&amp; !(t &amp; 1)) return 0; 42 &#125; 43 return 1; 44&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"类欧几里得","slug":"类欧几里得","date":"2020-03-07T08:59:02.288Z","updated":"2020-03-07T08:59:45.091Z","comments":true,"path":"2020/03/07/类欧几里得/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"类欧几里得的总结","text":"类欧几里得的总结 类欧几里得的作用类欧几里得主要用于加速下列三种函数（log）: f(a,b,c,n)=∑ni=0⌊ai+bc⌋f(a,b,c,n)=∑i=0n⌊ai+bc⌋ g(a,b,c,n)=∑ni=0⌊ai+bc⌋2g(a,b,c,n)=∑i=0n⌊ai+bc⌋2 h(a,b,c,n)=∑ni=0i⌊ai+bc⌋h(a,b,c,n)=∑i=0ni⌊ai+bc⌋ 模板1复制#pragma GCC optimize(3)2#include &lt;bits&#x2F;stdc++.h&gt;3typedef long long ll;45constexpr int mod &#x3D; 998244353;67constexpr ll inv2 &#x3D; 499122177;8constexpr ll inv6 &#x3D; 166374059;910ll f(ll a, ll b, ll c, ll n);11ll g(ll a, ll b, ll c, ll n);12ll h(ll a, ll b, ll c, ll n);1314struct Query &#123;15 ll f, g, h;16&#125;;1718Query solve(ll a, ll b, ll c, ll n) &#123;19 Query ans, tmp;20 if (a &#x3D;&#x3D; 0) &#123;21 ans.f &#x3D; (n + 1) * (b &#x2F; c) % mod;22 ans.g &#x3D; (b &#x2F; c) * n % mod * (n + 1) % mod * inv2 % mod;23 ans.h &#x3D; (n + 1) * (b &#x2F; c) % mod * (b &#x2F; c) % mod;24 return ans;25 &#125;26 if (a &gt;&#x3D; c || b &gt;&#x3D; c) &#123;27 tmp &#x3D; solve(a % c, b % c, c, n);28 ans.f &#x3D; (tmp.f + (a &#x2F; c) * n % mod * (n + 1) % mod * inv2 % mod + (b &#x2F; c) * (n + 1) % mod) % mod;29 ans.g &#x3D; (tmp.g + (a &#x2F; c) * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod + (b &#x2F; c) * n % mod * (n + 1) % mod * inv2 % mod) % mod;30 ans.h &#x3D; ((a &#x2F; c) * (a &#x2F; c) % mod * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod +31 (b &#x2F; c) * (b &#x2F; c) % mod * (n + 1) % mod + (a &#x2F; c) * (b &#x2F; c) % mod * n % mod * (n + 1) % mod +32 tmp.h + 2 * (a &#x2F; c) % mod * tmp.g % mod + 2 * (b &#x2F; c) % mod * tmp.f % mod) % mod;33 return ans;34 &#125;35 ll m &#x3D; (a * n + b) &#x2F; c;36 tmp &#x3D; solve(c, c - b - 1, a, m - 1);37 ans.f &#x3D; (n * (m % mod) % mod - tmp.f) % mod;38 ans.g &#x3D; (n * (n + 1) % mod * (m % mod) % mod - tmp.f - tmp.h) % mod * inv2 % mod;39 ans.h &#x3D; (n * (m % mod) % mod * ((m + 1) % mod) % mod - 2 * tmp.g - 2 * tmp.f - ans.f) % mod;40 return ans;41&#125;4243inline char nc() &#123;44 static char buf[1000000], *p1 &#x3D; buf, *p2 &#x3D; buf;45 return p1 &#x3D;&#x3D; p2 &amp;&amp; (p2 &#x3D; (p1 &#x3D; buf) + fread(buf, 1, 1000000, stdin), p1 &#x3D;&#x3D; p2) ? EOF : *p1++;46&#125;4748inline ll read() &#123;49 ll res &#x3D; 0;50 char ch;51 do ch &#x3D; nc(); while (ch &lt; 48 || ch &gt; 57);52 do res &#x3D; res * 10 + ch - 48, ch &#x3D; nc(); while (ch &gt;&#x3D; 48 &amp;&amp; ch &lt;&#x3D; 57);53 return res;54&#125;5556char pbuf[1 &lt;&lt; 20], *pp &#x3D; pbuf;57inline void push(const char &amp;c) &#123;58 if (pp - pbuf &#x3D;&#x3D; 1 &lt;&lt; 20) fwrite(pbuf, 1, 1 &lt;&lt; 20, stdout), pp &#x3D; pbuf;59 *pp++ &#x3D; c;60&#125;61inline void write(int x) &#123;62 static ll sta[35];63 ll top &#x3D; 0;64 do &#123;65 sta[top++] &#x3D; x % 10, x &#x2F;&#x3D; 10;66 &#125; while (x);67 while (top) push(sta[--top] + &#39;0&#39;);68&#125;6970int main() &#123;71 ll t &#x3D; read();72 ll n, a, b, c;73 while (t--) &#123;74 n &#x3D; read(), a &#x3D; read(), b &#x3D; read(), c &#x3D; read();75 Query ans &#x3D; solve(a, b, c, n);76 printf(&quot;%lld %lld %lld\\n&quot;, (ans.f + mod) % mod, (ans.h + mod) % mod, (ans.g + mod) % mod);77 &#125;78 return 0;79&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"扩展KMP","slug":"扩展KMP","date":"2020-03-07T08:58:06.322Z","updated":"2020-03-07T08:58:50.745Z","comments":true,"path":"2020/03/07/扩展KMP/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%89%A9%E5%B1%95KMP/","excerpt":"扩展KMP的总结","text":"扩展KMP的总结 题目传送门：HDU-6153 A Secret题目大意：给定两个串，求其中一个串s的每个后缀在另一个串t中出现的次数乘以其长度之和。 解题思路： 将S与T串反转，转换成求前缀问题 扩展KMP求S的每个后缀与T串的最长公共前缀（extend[i] 表示 S[i..n-1] 与 T 的最长公共前缀）。 然后遍历 extend 数组， 值不为零的加上一个等差数列的和（1，2，3…extend[i]）。 AC代码：1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3typedef long long ll;4const ll maxn &#x3D; 1000005;5const ll mod &#x3D; 1000000007;6ll nex[maxn], extend[maxn];7char a[maxn], b[maxn];8void pre_EKMP(char x[], ll m, ll nex[])9&#123;10 nex[0] &#x3D; m;11 ll j &#x3D; 0;12 while(j + 1 &lt; m &amp;&amp; x[j] &#x3D;&#x3D; x[j + 1])j++;13 nex[1] &#x3D; j;14 ll k &#x3D; 1;15 for(ll i &#x3D; 2; i &lt; m; i++)&#123;16 ll p &#x3D; nex[k] + k - 1;17 ll L &#x3D; nex[i - k];18 if(i + L &lt; p + 1)nex[i] &#x3D; L;19 else &#123;20 j &#x3D; max((ll)0, p - i + 1);21 while(i + j &lt; m &amp;&amp; x[i + j] &#x3D;&#x3D; x[j])j++;22 nex[i] &#x3D; j;23 k &#x3D; i;24 &#125;25 &#125;26&#125;27void EKMP(char x[], ll m, char y[], ll n, ll nex[], ll extend[])&#123;28 pre_EKMP(x, m, nex);29 ll j &#x3D; 0;30 while(j &lt; n &amp;&amp; j &lt; m &amp;&amp; x[j] &#x3D;&#x3D; y[j])j++;31 extend[0] &#x3D; j;32 ll k &#x3D; 0;33 for(ll i &#x3D; 1; i &lt; n; i++)34 &#123;35 ll p &#x3D; extend[k] + k - 1;36 ll L &#x3D; nex[i - k];37 if(i + L &lt; p + 1)extend[i] &#x3D; L;38 else39 &#123;40 j &#x3D; max((ll)0, p - i + 1);41 while(i + j &lt; n &amp;&amp; j &lt; m &amp;&amp; y[i + j] &#x3D;&#x3D; x[j])j++;42 extend[i] &#x3D; j;43 k &#x3D; i;44 &#125;45 &#125;46&#125;47int main()48&#123;49 ll t, n, m, i;50 scanf(&quot;%lld&quot;, &amp;t);51 while(t--)52 &#123;53 scanf(&quot;%s %s&quot;, a, b);54 n &#x3D; strlen(a), m &#x3D; strlen(b);55 for(i &#x3D; 0; i &lt; n &#x2F; 2; i++)swap(a[i],a[n - 1 - i]);56 for(i &#x3D; 0; i &lt; m &#x2F; 2; i++)swap(b[i],b[m - 1 - i]);57 EKMP(b, strlen(b), a, strlen(a), nex, extend);58 ll ans &#x3D; 0;59 for(i &#x3D; 0; i &lt; n; i++)60 &#123;61 ans +&#x3D; (1 + extend[i]) * extend[i] &#x2F; 2;62 ans %&#x3D; mod;63 &#125;64 printf(&quot;%lld\\n&quot;, ans);65 &#125;66&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"回文树","slug":"回文树","date":"2020-03-07T08:57:15.678Z","updated":"2020-03-07T08:57:55.734Z","comments":true,"path":"2020/03/07/回文树/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%9B%9E%E6%96%87%E6%A0%91/","excerpt":"回文树的总结","text":"回文树的总结 回文树详解今天我们来学习一个神奇的数据结构：Palindromic Tree。中译过来就是——回文树。 那么这个回文树有何功能？ 回文树的功能假设我们有一个串S，S下标从0开始，则回文树能做到如下几点： 1.求串S前缀0~i内本质不同回文串的个数（两个串长度不同或者长度相同且至少有一个字符不同便是本质不同） 2.求串S内每一个本质不同回文串出现的次数 3.求串S内回文串的个数（其实就是1和2结合起来） 4.求以下标i结尾的回文串的个数 回文树的构造过程那么我们该如何构造回文树？ 首先我们定义一些变量。 1.len[i]表示编号为i的节点表示的回文串的长度（一个节点表示一个回文串） 2.next[i][c]表示编号为i的节点表示的回文串在两边添加字符c以后变成的回文串的编号（和字典树类似）。 3.fail[i]表示节点i失配以后跳转不等于自身的节点i表示的回文串的最长后缀回文串（和AC自动机类似）。 4.cnt[i]表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的） 5.num[i]表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数。 6.last指向新添加一个字母后所形成的最长回文串表示的节点。 7.S[i]表示第i次添加的字符（一开始设S[0] = -1（可以是任意一个在串S中不会出现的字符））。 8.p表示添加的节点个数。 9.n表示添加的字符个数。 一开始回文树有两个节点，0表示偶数长度串的根和1表示奇数长度串的根，且len[0] = 0，len[1] = -1，last = 0，S[0] = -1，n = 0，p = 2（添加了节点0、1）。 假设现在我们有串S = abbaabba。 首先我们添加第一个字符’a’，S[++ n] = ‘a’，然后判断此时S[n - len[last] - 1]是否等于S[n]，即上一个串-1的位置和新添加的位置是否相同，相同则说明构成回文。否则，last = fail[last]。此时last = 0，我们发现S[1 - 0 - 1] != S[1]，所以last = fail[last] = 1，然后我们发现S[1 - (-1) - 1] == S[1]（即自己等于自己，所以我们让len[1]等于-1可以让这一步更加方便）。 令cur等于此时的last（即cur = last = 1），判断此时next[cur][‘a’]是否已经有后继，如果next[cur][‘a’]没有后继，我们就进行如下的步骤：新建节点（节点数p++，且之后p = 3），并让now等于新节点的编号（now = 2），则len[now] = len[cur] + 2（每一个回文串的长度总是在其最长子回文串的基础上在两边加上两个相同的字符构成的，所以是+2，同时体现出我们让len[1] = -1的优势，一个字符自成一个奇回文串时回文串的长度为(-1) + 2 = 1）。然后我们让fail[now] = next[get_fail ( fail[cur] )][‘a’]，即得到fail[now]（此时为fail[2] = 0），其中的get_fail函数就是让找到第一个使得S[n - len[last] - 1] == S[n]的last。然后next[cur][‘a’] = now。 当上面步骤完成后我们让last = next[cur][c]（不管next[cur][‘a’]是否有后继），然后cnt[last] ++。 此时回文树为下图状态： 现在我们添加第二个字符字符’b’到回文树中： 继续添加第三个字符’b’到回文树中： 继续添加第四个字符’a’到回文树中： 继续添加第五个字符’a’到回文树中： 继续添加第六个字符’b’到回文树中： 继续添加第七个字符’b’到回文树中： 继续添加第八个字符’a’到回文树中： 到此，串S已经完全插入到回文树中了，现在所有的数据如下： 然后我们将节点x在fail指针树中将自己的cnt累加给父亲，从叶子开始倒着加，最后就能得到串S中出现的每一个本质不同回文串的个数。 回文树的复杂度构造回文树需要的空间复杂度为O（N字符集大小），时间复杂度为O（Nlog（字符集大小）），这个时间复杂度比较神奇。如果空间需求太大，可以改成邻接表的形式存储，不过相应的要牺牲一些时间。 模板1复制#include &lt;iostream&gt;2#include&lt;bits&#x2F;stdc++.h&gt;3using namespace std;4const int MAXN &#x3D; 210005 ;5const int N &#x3D; 26 ;67struct Palindromic_Tree &#123;8 int next[MAXN][N] ;&#x2F;&#x2F;next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成9 int fail[MAXN] ;&#x2F;&#x2F;fail指针，失配后跳转到fail指针指向的节点10 long long cnt[MAXN] ;11 &#x2F;&#x2F;cnt[i]表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的）12 int num[MAXN] ; &#x2F;&#x2F;num[i]表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数13 int len[MAXN] ;&#x2F;&#x2F;len[i]表示节点i表示的回文串的长度14 int S[MAXN] ;&#x2F;&#x2F;存放添加的字符15 int last ;&#x2F;&#x2F;指向上一个字符所在的节点，方便下一次add16 int n ;&#x2F;&#x2F;字符数组指针17 int p ;&#x2F;&#x2F;节点指针1819 int newnode ( int l ) &#123;&#x2F;&#x2F;新建节点20 for ( int i &#x3D; 0 ; i &lt; N ; ++ i ) next[p][i] &#x3D; 0 ;21 cnt[p] &#x3D; 0 ;22 num[p] &#x3D; 0 ;23 len[p] &#x3D; l ;24 return p ++ ;25 &#125;2627 void init () &#123;&#x2F;&#x2F;初始化28 p &#x3D; 0 ;29 newnode (0) ;30 newnode (-1) ;31 last &#x3D; 0 ;32 n &#x3D; 0 ;33 S[n] &#x3D; -1 ;&#x2F;&#x2F;开头放一个字符集中没有的字符，减少特判34 fail[0] &#x3D; 1 ;35 &#125;3637 int get_fail ( int x ) &#123;&#x2F;&#x2F;和KMP一样，失配后找一个尽量最长的38 while ( S[n - len[x] - 1] !&#x3D; S[n] ) x &#x3D; fail[x] ;39 return x ;40 &#125;4142 void add ( int c ) &#123;43 c -&#x3D; &#39;a&#39; ;44 S[++ n] &#x3D; c ;45 &#x2F;&#x2F; cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;(char)(S[n]+&#39;a&#39;)&lt;&lt;endl;46 int cur &#x3D; get_fail ( last ) ;&#x2F;&#x2F;通过上一个回文串找这个回文串的匹配位置47 if ( !next[cur][c] ) &#123;&#x2F;&#x2F;如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串48 int now &#x3D; newnode ( len[cur] + 2 ) ;&#x2F;&#x2F;新建节点49 fail[now] &#x3D; next[get_fail ( fail[cur] )][c] ;&#x2F;&#x2F;和AC自动机一样建立fail指针，以便失配后跳转50 next[cur][c] &#x3D; now ;51 num[now] &#x3D; num[fail[now]] + 1 ;52 &#125;53 last &#x3D; next[cur][c] ;54 cnt[last] ++ ;55 &#125;5657 void count () &#123;58 for ( int i &#x3D; p - 1 ; i &gt;&#x3D; 0 ; -- i ) cnt[fail[i]] +&#x3D; cnt[i] ;59 &#x2F;&#x2F;父亲累加儿子的cnt，因为如果fail[v]&#x3D;u，则u一定是v的子回文串！60 &#125;61 void print()62 &#123;63 &#x2F;&#x2F;S[i]表示第i次添加的字符（一开始设S[0] &#x3D; -1（可以是任意一个在串S中不会出现的字符））64 for(int i&#x3D;1;i&lt;&#x3D;p-2;i++)65 &#123;66 printf(&quot;%c &quot;,S[i]+&#39;a&#39;);67 &#125;68 printf(&quot;\\n&quot;);69 for(int i&#x3D;2;i&lt;p;i++)70 &#123;71 printf(&quot;%d &quot;,cnt[i]);72 &#125;73 printf(&quot;\\n&quot;);74 for(int i&#x3D;2;i&lt;p;i++)75 &#123;76 printf(&quot;%d &quot;,num[i]);77 &#125;78 printf(&quot;\\n&quot;);79 &#125;80&#125; ;81Palindromic_Tree a1,b1;82long long ans;83char a[201312],b[223123];84void dfs(int x,int y)85&#123;8687 for(int i&#x3D;0;i&lt;N;i++)88 &#123;89 int x1 &#x3D;a1.next[x][i];90 int y1 &#x3D;b1.next[y][i];9192 if(x1&amp;&amp;y1)93 &#123;94 ans+&#x3D;(long long)(a1.cnt[x1]*b1.cnt[y1]);95 cout&lt;&lt;a1.cnt[x1]&lt;&lt;&quot; &quot;&lt;&lt;b1.cnt[y1]&lt;&lt;endl;96 dfs(x1,y1);97 &#125;98 &#125;99&#125;100int main()101&#123;102103 int T;104 cin&gt;&gt;T;105 int yy &#x3D;0;106 while(T--)107 &#123;108 scanf(&quot;%s%s&quot;,a,b);109 yy++;110 printf(&quot;Case #%d: &quot;,yy);111 int len1 &#x3D;strlen(a);112 int len2 &#x3D;strlen(b);113 a1.init();114 b1.init();115 for(int i&#x3D;0;i&lt;len1;i++)116 &#123;117 a1.add(a[i]);118 &#125;119 for(int i&#x3D;0;i&lt;len2;i++)120 &#123;121 b1.add(b[i]);122 &#125;123 a1.count();124 b1.count();125 a1.print();126 cout&lt;&lt;endl;127 b1.print();128 ans &#x3D;0 ;129 dfs(0,0);130 cout&lt;&lt;endl;131 cout&lt;&lt;endl;132 dfs(1,1);133 cout&lt;&lt;ans&lt;&lt;endl;134135 &#125;136 return 0;137&#125; 题集题集链接“https://cn.vjudge.net/contest/283852#overview&quot; 简易题解A UVALive 7041 【裸】题意：求两个串的公共回文串的个数。 B HDU 3068【裸】题意：求最长回文串的长度 C HDU 3948 【裸】题意：求出本质不同的回文串个数。 D HYSBZ 2565题意：求最长双回文子串的长度正着跑一遍，反着跑一遍即可。 E URAL 1960题意：求字符串的所有前缀 本质不同的回文串个数。在添加字符的过程中直接输出即可。 F HYSBZ 3676题意：我们定义s的一个子串t的“出现值”为t在s中的出现次数乘以t的长度。请你求出s的所有回文子串中的最大出现值。 G HDU 5658题意：给定一个串，询问l到r右多少本质不同的回文串。 H HDU 5157 题意 ：给定一个字符串str，求str的不相交的回文子串的对数。回文树num数组的运用。 I HYSBZ 2160题意：给一个字符串，求最长的k个回文子串（此处回文子串长度必须为奇数）长度的乘积。字符串长度≤1000000，即要将回文串按照长度从大到小选择k个出来,并求出长度乘积。 J HDU - 5785题意：给你一个串，定义了一个权值，每个权值是两个回文串拼起来的左右坐标乘积。求所有权值的和。 注意细节，不然会爆空间 K CodeForces 17E题意：求一个字符串中相交回文串的对数。 L HDU 5421（回文树扩展——可左右添加字符的回文树）题意：有n种操作，开始给你一个空串，给你4种操作。1 c 在字符串的首部添加字符c2 c 在字符串的尾部添加字符c3 询问字符中的本质不同的回文串的个数4 询问字符串中回文串的个数 参考博客https://blog.csdn.net/u013368721/article/details/42100363http://axuhongbo.top/tree/","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"后缀数组","slug":"后缀数组","date":"2020-03-07T08:56:07.340Z","updated":"2020-03-07T08:56:57.479Z","comments":true,"path":"2020/03/07/后缀数组/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","excerpt":"后缀数组的总结","text":"后缀数组的总结 Step1 - 后缀数组模板+详细注释1#include &lt;cstdio&gt;2using namespace std;3const int MAXN &#x3D; 100005;4&#x2F;&#x2F;rnk从0开始5&#x2F;&#x2F;sa从1开始,因为最后一个字符(最小的)排在第0位6&#x2F;&#x2F;height从1开始,因为表示的是sa[i - 1]和sa[i]7&#x2F;&#x2F;倍增算法 O(nlogn)8int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];9&#x2F;&#x2F;Suffix函数的参数m代表字符串中字符的取值范围,是基数排序的一个参数,如果原序列都是字母可以直接取128,如果原序列本身都是整数的话,则m可以取比最大的整数大1的值10&#x2F;&#x2F;待排序的字符串放在r数组中,从r[0]到r[n-1]，长度为n11&#x2F;&#x2F;为了方便比较大小,可以在字符串后面添加一个字符,这个字符没有在前面的字符中出现过,而且比前面的字符都要小12&#x2F;&#x2F;同上,为了函数操作的方便,约定除r[n-1]外所有的r[i]都大于0,r[n-1]&#x3D;013&#x2F;&#x2F;函数结束后,结果放在sa数组中,从sa[0]到sa[n-1]14void Suffix(int *r, int *sa, int n, int m)15&#123;16 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;17 &#x2F;&#x2F;对长度为1的字符串排序18 &#x2F;&#x2F;一般来说,在字符串的题目中,r的最大值不会很大,所以这里使用了基数排序19 &#x2F;&#x2F;如果r的最大值很大,那么把这段代码改成快速排序20 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;21 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;&#x2F;&#x2F;统计字符的个数22 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];&#x2F;&#x2F;统计不大于字符i的字符个数23 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;&#x2F;&#x2F;计算字符排名24 &#x2F;&#x2F;基数排序25 &#x2F;&#x2F;x数组保存的值相当于是rank值26 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)27 &#123;28 &#x2F;&#x2F;j是当前字符串的长度,数组y保存的是对第二关键字排序的结果29 &#x2F;&#x2F;第二关键字排序30 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;&#x2F;&#x2F;第二关键字为0的排在前面31 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;&#x2F;&#x2F;长度为j的子串sa[i]应该是长度为2 * j的子串sa[i] - j的后缀（第二关键字）,对所有的长度为2 * j的子串根据第二关键字来排序32 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];&#x2F;&#x2F;提取第一关键字33 &#x2F;&#x2F;按第一关键字排序 (原理同对长度为1的字符串排序)34 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;35 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;36 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];37 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];&#x2F;&#x2F;按第一关键字,计算出了长度为2 * j的子串排名情况38 &#x2F;&#x2F;此时数组x是长度为j的子串的排名情况,数组y仍是根据第二关键字排序后的结果39 &#x2F;&#x2F;计算长度为2 * j的子串的排名情况,保存到数组x40 t &#x3D; x;41 x &#x3D; y;42 y &#x3D; t;43 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)44 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;45 &#x2F;&#x2F;若长度为2 * j的子串sa[i]与sa[i - 1]完全相同,则他们有相同的排名46 &#125;47&#125;48int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];49void calheight(int *r,int *sa,int n)50&#123;51 int i,j,k&#x3D;0;52 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;53 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)54 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);55&#125; Step2 - 模板的使用1scanf(&quot;%s&quot;, str);2int len &#x3D; strlen(str);3for(i &#x3D; 0; i &lt; len; i++)4&#123;5 r[i] &#x3D; str[i] - &#39;a&#39; + 1;&#x2F;&#x2F;将字符串填入r数组6&#125;7r[i] &#x3D; 0;&#x2F;&#x2F;末尾添加一个字符集中没有的树，保证字典序最小，便于编排数组8Suffix(r, sa, len + 1, m);&#x2F;&#x2F;m为字符集大小9calheight(r, sa, len);&#x2F;&#x2F;求 Height 数组 Step3 - 后缀数组的应用Step3.1 - 最长公共前缀题目大意：给定一个字符串，询问某两个后缀的最长公共前缀。 解题思路：按照上面所说的做法，求两个后缀的最长公共前缀可以转化为求某个区间上 的最小值。对于这个 RMQ 问题（如果对 RMQ 问题不熟悉，请阅读其他相关资料）， 可以用 O(nlogn)的时间先预处理，以后每次回答询问的时间为 O(1)。所以对于 本问题，预处理时间为 O(nlogn)，每次回答询问的时间为 O(1)。如果 RMQ 问题 用 O(n)的时间预处理，那么本问题预处理的时间可以做到 O(n)。 代码：1#include &lt;cstdio&gt;2#include &lt;cstring&gt;3#include &lt;cmath&gt;4#include &lt;algorithm&gt;5using namespace std;6&#x2F;&#x2F;后缀数组部分7const int MAXN &#x3D; 100005;8int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];9void Suffix(int *r, int *sa, int n, int m)10&#123;11 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;12 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;13 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;14 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];15 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;16 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)17 &#123;18 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;19 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;20 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];21 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;22 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;23 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];24 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];25 t &#x3D; x;26 x &#x3D; y;27 y &#x3D; t;28 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)29 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;30 &#125;31&#125;32int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];33void calheight(int *r,int *sa,int n)34&#123;35 int i,j,k&#x3D;0;36 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;37 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)38 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);39&#125;40&#x2F;&#x2F;RMQ部分41int n,minnum[MAXN][17];42void RMQ() &#x2F;&#x2F;预处理 O(nlogn)43&#123;44 int i,j;45 int m&#x3D;(int)(log(n*1.0)&#x2F;log(2.0));46 for(i&#x3D;1;i&lt;&#x3D;n;i++)47 minnum[i][0]&#x3D;height[i];48 for(j&#x3D;1;j&lt;&#x3D;m;j++)49 for(i&#x3D;1;i+(1&lt;&lt;j)-1&lt;&#x3D;n;i++)50 minnum[i][j]&#x3D;min(minnum[i][j-1],minnum[i+(1&lt;&lt;(j-1))][j-1]);51&#125;52int ask(int a,int b) &#x2F;&#x2F;O(1)53&#123;54 int k&#x3D;int(log(b-a+1.0)&#x2F;log(2.0));55 return min(minnum[a][k],minnum[b-(1&lt;&lt;k)+1][k]);56&#125;57int askpre(int a,int b)58&#123;59 a&#x3D;Rank[a],b&#x3D;Rank[b];60 if(a&gt;b)61 swap(a,b);62 return ask(a+1,b);63&#125;64char str[MAXN];65int main()66&#123;67 scanf(&quot;%s&quot;, str);68 n &#x3D; strlen(str);69 int i;70 for(i &#x3D; 0; i &lt; n; i++)71 &#123;72 r[i] &#x3D; str[i] - &#39;a&#39; + 1;73 &#125;74 r[i] &#x3D; 0;75 Suffix(r, sa, n + 1, 27);76 calheight(r, sa, n);77 RMQ();78 int q;79 scanf(&quot;%d&quot;, &amp;q);80 while(q--)81 &#123;82 int l, r;&#x2F;&#x2F; 0 &lt;&#x3D; l &lt;&#x3D; r &lt; n83 scanf(&quot;%d %d&quot;, &amp;l, &amp;r);84 printf(&quot;%d\\n&quot;, askpre(l, r));85 &#125;86 return 0;87&#125; Step3.2 - 单个字符串的相关问题这类问题的一个常用做法是先求后缀数组和 height 数组，然后利用 height 数组进行求解。 1. 重复子串1.1 可重叠最长重复子串题目大意：给定一个字符串，求最长重复子串，这两个子串可以重叠。 解题思路：这道题是后缀数组的一个简单应用。做法比较简单，只需要求 height 数组 里的最大值即可。首先求最长重复子串，等价于求两个后缀的最长公共前缀的最 大值。因为任意两个后缀的最长公共前缀都是 height 数组里某一段的最小值， 那么这个值一定不大于 height 数组里的最大值。所以最长重复子串的长度就是 height 数组里的最大值。这个做法的时间复杂度为 O(n)。 1.2 不可重叠最长重复子串（poj 1743）题目大意：给定一个字符串，求最长重复子串，这两个子串不能重叠。 解题思路：这题比上一题稍复杂一点。先二分答案，把题目变成判定性问题：判断是否 存在两个长度为 k 的子串是相同的，且不重叠。解决这个问题的关键还是利用 height 数组。把排序后的后缀分成若干组，其中每组的后缀之间的 height 值都 不小于 k。例如，字符串为“aabaaaab”，当 k=2 时，后缀分成了 4 组，如图 所示。 容易看出，有希望成为最长公共前缀不小于 k 的两个后缀一定在同一组。然 后对于每组后缀，只须判断每个后缀的 sa 值的最大值和最小值之差是否不小于 k。如果有一组满足，则说明存在，否则不存在。整个做法的时间复杂度为 O(nlogn)。本题中利用 height 值对后缀进行分组的方法很常用，请读者认真体 会。 代码（待测）1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4#define ll long long5using namespace std;6const int MAXN &#x3D; 100005;7int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];8void Suffix(int *r, int *sa, int n, int m)9&#123;10 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;11 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;12 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;13 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];14 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;15 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)16 &#123;17 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;18 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;19 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];20 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;21 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;22 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];23 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];24 t &#x3D; x;25 x &#x3D; y;26 y &#x3D; t;27 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)28 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;29 &#125;30&#125;31int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];32void calheight(int *r,int *sa,int n)33&#123;34 int i,j,k&#x3D;0;35 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;36 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)37 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);38&#125;39int n;40int check(int k)41&#123;42 int mx &#x3D; -0x3f3f3f, mm &#x3D; 0x3f3f3f;43 for(int i &#x3D; 2; i &lt;&#x3D; n; i++)44 &#123;45 if(height[i] &gt;&#x3D; k)46 &#123;47 mm &#x3D; min(mm, min(sa[i], sa[i - 1]));48 mx &#x3D; max(mx, max(sa[i], sa[i - 1]));49 if(mx - mm &gt; k)return 1;&#x2F;&#x2F;如果两个sa相差大于k（等于k不行）则答案可行50 &#125;51 else52 &#123;53 mx &#x3D; -0x3f3f3f, mm &#x3D; 0x3f3f3f;&#x2F;&#x2F;重新分组54 &#125;55 &#125;56 return 0;57&#125;58int main()59&#123;60 int i;61 while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)62 &#123;63 if(n &#x3D;&#x3D; 0)break;64 for(i &#x3D; 0; i &lt; n; i++)scanf(&quot;%d&quot;, &amp;r[i]);65 n--;66 for(i &#x3D; 0; i &lt; n; i++)r[i] &#x3D; r[i + 1] - r[i] + 89;&#x2F;&#x2F;求差值去掉负数67 r[i] &#x3D; 0;68 Suffix(r, sa, n + 1, 300);69 calheight(r, sa, n);70 int l &#x3D; 0, r &#x3D; n &#x2F; 2;71 while(l &lt; r)&#x2F;&#x2F;二分答案72 &#123;73 int mid &#x3D; (l + r + 1) &#x2F; 2;74 if(check(mid))l &#x3D; mid;75 else r &#x3D; mid - 1;76 &#125;77 if(l &gt;&#x3D; 4)printf(&quot;%d\\n&quot;, l + 1);&#x2F;&#x2F;78 else printf(&quot;0\\n&quot;);79 &#125;80 return 0;81&#125; 1.3 可重叠的 k 次最长重复子串（poj3261）题目大意：给定一个字符串，求至少出现 k 次的最长重复子串，这 k 个子串可以重叠。 解题思路：这题的做法和上一题差不多，也是先二分答案，然后将后缀分成若干组。不 同的是，这里要判断的是有没有一个组的后缀个数不小于 k。如果有，那么存在 k 个相同的子串满足条件，否则不存在。这个做法的时间复杂度为 O(nlogn)。 代码（待测）1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4#define ll long long5using namespace std;6const int MAXN &#x3D; 1000005;7int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];8void Suffix(int *r, int *sa, int n, int m)9&#123;10 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;11 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;12 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;13 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];14 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;15 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)16 &#123;17 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;18 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;19 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];20 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;21 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;22 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];23 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];24 t &#x3D; x;25 x &#x3D; y;26 y &#x3D; t;27 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)28 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;29 &#125;30&#125;31int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];32void calheight(int *r,int *sa,int n)33&#123;34 int i,j,k&#x3D;0;35 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;36 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)37 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);38&#125;39int n;40int check(int k, int x)41&#123;42 int sum &#x3D; 1;43 for(int i &#x3D; 2; i &lt;&#x3D; n; i++)44 &#123;45 if(height[i] &gt;&#x3D; k)46 &#123;47 sum++;48 &#125;49 else50 &#123;51 sum &#x3D; 1;52 &#125;53 if(sum &gt;&#x3D; x)return 1;54 &#125;55 return 0;56&#125;57int main()58&#123;59 int i, k;60 scanf(&quot;%d %d&quot;, &amp;n, &amp;k);61 for(i &#x3D; 0; i &lt; n; i++)scanf(&quot;%d&quot;, &amp;r[i]);62 r[i] &#x3D; 0;63 Suffix(r, sa, n + 1, 1000005);64 calheight(r, sa, n);65 if(k &#x3D;&#x3D; 1)66 &#123;67 printf(&quot;%d\\n&quot;, n);68 &#125;69 else70 &#123;71 if(k &#x3D;&#x3D; 2)72 &#123;73 int ans &#x3D; 0;74 for(i &#x3D; 1; i &lt;&#x3D; n; i++)ans &#x3D; max(ans, height[i]);75 printf(&quot;%d\\n&quot;, ans);76 &#125;77 else78 &#123;79 int l &#x3D; 0, r &#x3D; n;80 while(l &lt; r)81 &#123;82 int mid &#x3D; (l + r + 1) &#x2F; 2;83 if(check(mid, k))l &#x3D; mid;84 else r &#x3D; mid - 1;85 &#125;86 printf(&quot;%d\\n&quot;, l);87 &#125;88 &#125;89 return 0;90&#125; 2. 子串的个数2.1 不相同的子串的个数（spoj694,spoj705）题目大意：给定一个字符串，求不相同的子串的个数。 解题思路：每个子串一定是某个后缀的前缀，那么原问题等价于求所有后缀之间的不相 同的前缀的个数。如果所有的后缀按照 suffix(sa[1]), suffix(sa[2]), suffix(sa[3]), …… ,suffix(sa[n])的顺序计算，不难发现，对于每一次新加 进来的后缀 suffix(sa[k]),它将产生 n-sa[k]+1 个新的前缀。但是其中有 height[k]个是和前面的字符串的前缀是相同的。所以 suffix(sa[k])将“贡献” 出 n-sa[k]+1- height[k]个不同的子串。累加后便是原问题的答案。这个做法 的时间复杂度为 O(n)。 代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4#define ll long long5using namespace std;6const int MAXN &#x3D; 1000005;7int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];8void Suffix(int *r, int *sa, int n, int m)9&#123;10 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;11 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;12 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;13 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];14 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;15 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)16 &#123;17 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;18 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;19 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];20 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;21 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;22 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];23 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];24 t &#x3D; x;25 x &#x3D; y;26 y &#x3D; t;27 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)28 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;29 &#125;30&#125;31int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];32void calheight(int *r,int *sa,int n)33&#123;34 int i,j,k&#x3D;0;35 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;36 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)37 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);38&#125;39int n;40char str[MAXN];41int main()42&#123;43 int t, i;44 scanf(&quot;%d&quot;, &amp;t);45 while (t--) &#123;46 scanf(&quot;%s&quot;, str);47 n &#x3D; strlen(str);48 for(i &#x3D; 0; i &lt; n; i++)r[i] &#x3D; str[i];49 r[i] &#x3D; 0;50 Suffix(r, sa, n + 1, 300);51 calheight(r, sa, n);52 ll ans &#x3D; 0;53 for (i &#x3D; 1; i &lt;&#x3D; n; i++) ans +&#x3D; n-sa[i]-height[i];54 printf(&quot;%lld\\n&quot;, ans);55 &#125;56 return 0;&#x2F;&#x2F;57&#125; 3. 回文子串留坑4. 连续重复字串4.1 连续重复子串(poj2406)题目大意：给定一个字符串 L，已知这个字符串是由某个字符串 S 重复 R 次而得到的， 求 R 的最大值。 解题思路：做法比较简单，穷举字符串 S 的长度 k，然后判断是否满足。判断的时候， 先看字符串 L 的长度能否被 k 整除，再看 suffix(1)和 suffix(k+1)的最长公共 前缀是否等于 n-k。在询问最长公共前缀的时候，suffix(1)是固定的，所以 RMQ 问题没有必要做所有的预处理，只需求出 height 数组中的每一个数到 height[rank[1]]之间的最小值即可。整个做法的时间复杂度为 O(n)。 也可以使用 KMP 最小循环节解决 代码（待测）留坑4.2 重复次数最多的连续重复子串(SPOJ-REPEATS)题目大意：给定一个字符串，求重复次数最多的连续重复子串。 解题思路：先穷举长度 L，然后求长度为 L 的子串最多能连续出现几次。首先连续出现 1 次是肯定可以的，所以这里只考虑至少 2 次的情况。假设在原字符串中连续出 现 2 次，记这个子字符串为 S，那么 S 肯定包括了字符 r[0], r[L], r[L2], r[L3], ……中的某相邻的两个。所以只须看字符 r[Li]和 r[L(i+1)]往前和 往后各能匹配到多远，记这个总长度为 K，那么这里连续出现了 K/L+1 次。最后 看最大值是多少。如图所示。 穷举长度 L 的时间是 n，每次计算的时间是 n/L。所以整个做法的时间复杂 度是 O(n/1+n/2+n/3+……+n/n)=O(nlogn)。 代码：1#include &lt;cstdio&gt;2#include &lt;cmath&gt;3#include &lt;cstring&gt;4#include &lt;algorithm&gt;5using namespace std;6const int MAXN &#x3D; 50005;7int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];8void Suffix(int *r, int *sa, int n, int m)9&#123;10 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;11 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;12 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;13 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];14 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;15 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)16 &#123;17 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;18 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;19 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];20 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;21 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;22 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];23 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];24 t &#x3D; x;25 x &#x3D; y;26 y &#x3D; t;27 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)28 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;29 &#125;30&#125;31int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];32void calheight(int *r,int *sa,int n)33&#123;34 int i,j,k&#x3D;0;35 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;36 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)37 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);38&#125;39int n,minnum[MAXN][16];40void RMQ()41&#123;42 int i,j;43 int m&#x3D;(int)(log(n*1.0)&#x2F;log(2.0));44 for(i&#x3D;1;i&lt;&#x3D;n;i++)45 minnum[i][0]&#x3D;height[i];46 for(j&#x3D;1;j&lt;&#x3D;m;j++)47 for(i&#x3D;1;i+(1&lt;&lt;j)-1&lt;&#x3D;n;i++)48 minnum[i][j]&#x3D;min(minnum[i][j-1],minnum[i+(1&lt;&lt;(j-1))][j-1]);49&#125;50int Ask_MIN(int a,int b)51&#123;52 int k&#x3D;int(log(b-a+1.0)&#x2F;log(2.0));53 return min(minnum[a][k],minnum[b-(1&lt;&lt;k)+1][k]);54&#125;55int calprefix(int a,int b)56&#123;57 a&#x3D;Rank[a],b&#x3D;Rank[b];58 if(a&gt;b)59 swap(a,b);60 return Ask_MIN(a+1,b);61&#125;62char s[5];63int main()64&#123;65 int t,i,j,k,ans,Max;66 scanf(&quot;%d&quot;,&amp;t);67 while(t--)68 &#123;69 Max&#x3D;1;70 scanf(&quot;%d&quot;,&amp;n);71 for(i&#x3D;0;i&lt;n;i++)72 &#123;73 scanf(&quot;%s&quot;,s);74 r[i]&#x3D;s[0]-&#39;a&#39;+1;75 &#125;76 r[i]&#x3D;0;77 Suffix(r,sa,n+1,3);78 calheight(r,sa,n);79 RMQ();80 for(i&#x3D;1;i&lt;&#x3D;n;i++)81 &#123;82 for(j&#x3D;0;j+i&lt;n;j+&#x3D;i)83 &#123;84 ans&#x3D;calprefix(j,j+i);85 k&#x3D;j-(i-ans%i);86 ans&#x3D;ans&#x2F;i+1;87 if(k&gt;&#x3D;0&amp;&amp;calprefix(k,k+i)&gt;&#x3D;i)88 ans++;89 Max&#x3D;max(Max,ans);90 &#125;91 &#125;92 printf(&quot;%d\\n&quot;,Max);93 &#125;94 return 0;95&#125; Step3.3 - 两个字符串的相关问题这类问题的一个常用做法是，先连接这两个字符串，然后求后缀数组和 height 数组，再利用 height 数组进行求解。 1. 最长公共字串题目大意：给定两个字符串 A 和 B，求最长公共子串。 解题思路：分隔符将两个字符串连接 后缀数组求height数组后 只要相邻两个分别在两串，就可以用height更新ans 代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4#include &lt;iostream&gt;5#include &lt;cmath&gt;6#define ll long long7using namespace std;8const int MAXN &#x3D; 50005;9int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];10void Suffix(int *r, int *sa, int n, int m)11&#123;12 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;13 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;14 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;15 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];16 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;17 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)18 &#123;19 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;20 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;21 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];22 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;23 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;24 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];25 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];26 t &#x3D; x;27 x &#x3D; y;28 y &#x3D; t;29 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)30 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;31 &#125;32&#125;33int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];34void calheight(int *r,int *sa,int n)35&#123;36 int i,j,k&#x3D;0;37 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;38 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)39 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);40&#125;41char a[MAXN], b[MAXN];42int n;43int main()44&#123;45 int i;46 scanf(&quot;%s %s&quot;, a, b);47 int lena &#x3D; strlen(a);48 int lenb &#x3D; strlen(b);49 for(i &#x3D; 0; i &lt; lena; i++)50 &#123;51 r[i] &#x3D; a[i];52 &#125;53 r[lena] &#x3D; &#39;#&#39;;54 for(i &#x3D; 0; i &lt; lenb; i++)55 &#123;56 r[i + lena + 1] &#x3D; b[i];57 &#125;58 r[lena + lenb + 1] &#x3D; 0;59 Suffix(r, sa, lena + lenb + 2, 300);60 calheight(r, sa, lena + lenb + 1);61 n &#x3D; lena + lenb + 1;62 int ans &#x3D; 0;63 for(int i &#x3D; 2; i &lt;&#x3D; n; i++)64 &#123;65 int pos1 &#x3D; sa[i - 1];66 int pos2 &#x3D; sa[i];67 if(pos1 &lt;&#x3D; lena &amp;&amp; pos2 &lt;&#x3D; lena)continue;68 else if(pos1 &gt; lena + 1&amp;&amp; pos2 &gt; lena + 1)continue;69 else ans &#x3D; max(ans, height[i]);70 &#125;71 printf(&quot;%d\\n&quot;, ans);72&#125; 2. 子串的个数留坑Step3.4 - 多个字符串的相关问题留坑","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"二分匹配","slug":"二分匹配","date":"2020-03-07T08:53:28.082Z","updated":"2020-03-07T08:54:04.181Z","comments":true,"path":"2020/03/07/二分匹配/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D/","excerpt":"二分匹配的总结","text":"二分匹配的总结 HYSBZ - 1143 祭祀river (二分图最大匹配)1#include &lt;bits/stdc++.h&gt;2using namespace std;3int a[105][105] = &#123;0&#125;;4int pre[205], s[205] = &#123;0&#125;, vis[105];5int cat(int x, int n)6&#123;7 int i;8 for(i = 1; i &lt;= n; i++)9 &#123;10 if(vis[i] == 0 &amp;&amp; a[x][i])11 &#123;12 vis[i] = 1;13 if(!s[i] || cat(s[i], n))14 &#123;15 s[i] = x;16 return 1;17 &#125;18 &#125;19 &#125;20 return 0;21&#125;22int main()23&#123;24 int n, m, i, j, k, u, v;25 scanf(\"%d %d\", &amp;n, &amp;m);26 for(i = 1; i &lt;= m; i++)27 &#123;28 scanf(\"%d %d\", &amp;u, &amp;v);29 a[u][v] = 1;30 &#125;31 for(k = 1; k &lt;= n; k++)32 &#123;33 for(i = 1; i &lt;= n; i++)34 &#123;35 for(j = 1; j &lt;= n; j++)36 &#123;37 if(a[i][k] == 1 &amp;&amp; a[k][j] == 1)a[i][j] = 1;38 &#125;39 &#125;40 &#125;41 int ans = 0;42 for(i = 1; i &lt;= n; i++)43 &#123;44 memset(vis, 0, sizeof(vis));45 if(cat(i, n))ans++;46 &#125;47 printf(\"%d\\n\", n - ans);48&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"堆与哈夫曼树","slug":"堆与哈夫曼树","date":"2020-03-07T08:52:19.131Z","updated":"2020-03-07T08:53:01.753Z","comments":true,"path":"2020/03/07/堆与哈夫曼树/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%A0%86%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/","excerpt":"堆与哈夫曼树的总结","text":"堆与哈夫曼树的总结 堆与哈夫曼树堆前置知识(5min)什么是二叉树二叉树是每个结点最多有两个子树的树结构 什么是满二叉树一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树 什么是完全二叉树对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树 用一张图可以较清楚的展示三者的区别 堆是什么(0.5min)堆是计算机科学中的一类数据结构 堆有什么特点(5min) 堆总是一颗完全二叉树 堆中任意一个节点总是不大于（或不小于）其父节点的值 [换言之，任意一个父节点的值一定大于等于（或小于等于）其所有子节点的值] 例如： 上述完全二叉树中，任意一个节点的值一定大于其子节点的值 7 &gt; 4 且 7 &gt; 6 4 &gt; 1 且 4 &gt; 3 6 &gt; 2 且 6 &gt; 5 因此，这课完全二叉树就可以叫做堆 补充： 任意父节点大于等于子节点的堆叫大顶堆 任意父节点小于等于子节点的堆叫小顶堆 堆有什么用(4.5min)基于堆的特点，我们发现堆可以： 快速获取一些元素中最大的值（或最小的值）（通过查询根节点的值实现） 通过不断取出当前元素中最大（或最小）的值来实现排序 例如： 现在有一个堆，堆中的元素有[6, 8, 4]，规定这是一个大顶堆。 首先我们取出根节点，也就是 8，把 8 放入序列 然后继续取出根节点，这时根节点是 6，把 6 放入序列 然后继续取出根节点，这时根节点是 4，把 4 放入序列 排序完成，新序列为[8, 6, 4]。 如何建立一个堆(15min)完全二叉树的一个性质(7min) 上图是一颗完全二叉树，红字部分为给每个节点的标号，不难发现这样一个特点： 对于任意一个节点，其左儿子标号=该节点标号*2，其右儿子标号=该节点标号 *2+1 上图中： 2 = 1 * 2， 3 = 1 * 2 + 1 4 = 2 * 2， 5 = 2 * 2 + 1 6 = 3 * 2， 7 = 3 * 2 + 1 用数组表示树(7.5min)基于上面得到的性质，可以用一段数组来表示一颗完全二叉树，而不再使用树形结构。 只需按照标号顺序依次向数组中放入每个节点即可用数组表示完全二叉树 例如在发现完全二叉树性质时使用的例子： 其数组表示为： [7, 4, 6, 1, 3, 2, 5] 其标号顺序为： [1, 2, 3, ,4, 5, 6, 7] 用数组建立一个空堆(0.5min)那么如果要建立一个空堆（即没有任何元素的堆），只需要声明一个数组即可，因为堆本质就是一颗特殊的完全二叉树。 之后的讨论中默认新建的这个堆为大顶堆 1int heap[N]; 向堆中插入一个元素(15min)在尾部添加新元素(3min)现在向堆中插入第一个元素，我们只需要在数组的尾部插入即可，例如我们插入 4 现在数组变为[4]，表现为树形结构为： 然后，插入第二个元素 6 现在数组变为[4, 6]，很显然 6 是 4的子节点，但4 &lt; 6，不符合大顶堆的性质，那么也就是说： 我们每次在数组尾部添加了一个新元素，需要重新维护数组中元素的顺序来保证堆的性质 调整位置以保证堆的性质(12min)首先，我们来看一个插入元素的过程动画 在这个动画中，我们可以观察到，我们在堆的尾部添加了一个元素这个元素是不符合大顶堆的性质的，于是我们会对元素的位置进行调整。 可以比较清楚的发现，调整过程中，新插入元素一直在不停的与他的父亲节点交换，直到整棵完全二叉树合法 于是，我们可以这样编码： 1heap[++len] = val; // heap为堆数组，len为当前长度， val为新插入的元素，该步骤实现在尾部插入新元素2int temp_pos = len; //定义临时变量存储新添加元素当前的位置3while(temp_pos &gt; 1 &amp;&amp; heap[temp_pos] &gt; heap[temp_pos / 2])// temp_pos &gt; 1 保证了当前位置节点有父节点，根据完全二叉树性质，我们不难推断：一个节点的父节点标号=当前节点标号/2，heap[temp_pos] &gt; heap[temp_pos / 2]保证了当前元素还没有到达合适位置4&#123;5 swap(a[temp_pos], a[temp_pos/2]); //交换当前节点与父节点6 temp_pos /= 2; // 更新元素的当前位置7&#125; 从堆中取出一个最大值(15min)将首部元素取出(0.5min)一般情况下，对我们有用的元素往往是根节点的值（也就是最值）， 因此，我们要取出最大值，首先要将首部元素提出。 将尾部元素调整至首部(0.5min)首部元素提出后，首部位置将会闲置，为了保证堆仍然是一颗完全二叉树，我们将尾部元素调整至首部 调整位置以保证堆得性质(14min)同样的，调整之后堆的性质将被打乱，我们需要重新将首部元素调整至合适位置以保证堆的性质 我们来看一下删除元素的动画 从动画中我们可以看出，将尾部调整至首部后，首部元素不符合堆的性质，因此不断与比本身大的子节点交换（两个子节点都比本身大时与较大的子节点交换），直至整个堆合法。 因此，我们可以这样编码 1int maxn = heap[1]; // 取出最大值，赋值给maxn2heap[1] = heap[len--]; // 将尾部元素调至首部，并改变堆的大小3int temp_pos = 1; // temp_pos 表示首部元素的当前位置4while(temp_pos * 2 &lt;= len) // 保证当前节点有子节点5&#123;6 if(temp_pos*2+1&lt;=len) // 如果当前节点有两个子节点7 &#123;8 if(heap[temp_pos*2]&gt;=heap[temp_pos*2+1]&amp;&amp;heap[temp_pos*2]&gt;=heap[temp_pos])9 // 如果左子节点是两个子节点中最大的10 swap(heap[temp_pos*2],heap[temp_pos]),temp_pos=temp_pos*2; // 交换当前节点与左子节点11 else if (heap[temp_pos*2+1]&gt;=heap[temp_pos*2]&amp;&amp;heap[temp_pos*2+1]&gt;=heap[temp_pos])12 // 如果右子节点是两个子节点中最大的13 swap(heap[temp_pos*2+1],heap[temp_pos]),temp_pos=temp_pos*2+1; // 交换当前节点与右子节点14 else break; // 除此之外，表明堆已合法15 &#125;16 else // 如果当前节点有一个子节点17 &#123;18 if(heap[temp_pos*2] &gt;= heap[temp_pos]) //如果子节点大于当前节点19 swap(heap[temp_pos*2], heap[temp_pos]),temp_pos=temp_pos*2; //交换当前节点与子节点20 else break; // 除此之外，表明堆已合法21 &#125;22&#125; *线性建堆至此，堆的基本内容已经给大家讲完了，已经了解时间复杂度的大家可以对堆的建立，删除，插入进行一个简单的分析，其实不难得出，一次插入与删除的复杂度均为O（log n） 现在，我们有n个元素，如果我们用上面所介绍的方法建堆，将插入n次，每次复杂度为O（log n），总复杂度为O（n*log n） 事实上，我们有线性时间建堆的方法，即复杂度O（n）的建堆方法 下面我们通过动画了解一下： 通过动画我们可以发现，线性建堆的方法，在于一开始即将无序的元素放入堆数组中， 然后从尾部元素开始，逐个向下调整（过程类似于删除首部元素后的调整），直到首部元素向下调整的过程结束， 一个符合堆性质的堆数组即建立完成 下面通过伪代码的方式给大家呈现整个过程的编码实现： 1for(int i = len; i &gt;= 1; i--)&#123;2 if(i * 2 &gt; len)continue; // 无子节点时直接跳过3 down(i); //向下调整4&#125; 其中down()函数不再给出，具体实现请大家参考从堆中取出最大值的操作。 编码完了，我们还有一个问题没有解决，即： 为什么这样操作的复杂度是O（n）的？ 关于这个问题感兴趣的同学可以移步线性建堆复杂度证明去了解一下，在这里不做赘述 使用堆来排序(4.5min)排序过程中，不断从堆顶（即根节点取出元素）即可，伪代码如下： 1int p[N], len = 0;2while(heap不为空)&#123;3 p[++len] = 取出堆顶();4&#125; 使用堆来找出一个集合中的最值(0.5min)建好堆后获取根节点的值即可 哈夫曼树(10min)*什么是哈夫曼树(5min)给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 *如何构建一颗哈夫曼树(3min)可以通过将元素压入小顶堆，每次取出两个元素，权值相加作为两个元素的根节点，同时将根节点压入堆中，直到堆中只剩下一个元素，则哈夫曼树建成 哈夫曼树有什么用(2min)一道经典的例题：SDUTOJ 树-堆结构练习——合并果子之哈夫曼树 解题思路： 因为哈夫曼树是带权路径长度最短的树，所以本题可以通过构建哈夫曼树的思路解决，即： 将所有元素压入小顶堆中，每次取出两个元素相加，压入堆，直到堆中只剩一个元素，则该元素为最终答案 参考资料百度百科：二叉树 百度百科：满二叉树 百度百科：完全二叉树 二叉树,完全二叉树,满二叉树,完美二叉树 数据结构：堆（Heap） 堆排序中建堆过程的时间复杂度O(n)的证明 百度百科：堆 百度百科：哈夫曼树 SDUTOJ 树-堆结构练习——合并果子之哈夫曼树 可视化数据结构学习VisuAlgo—二叉堆","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"单调栈","slug":"单调栈","date":"2020-03-07T08:51:22.502Z","updated":"2020-03-07T08:52:07.216Z","comments":true,"path":"2020/03/07/单调栈/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%8D%95%E8%B0%83%E6%A0%88/","excerpt":"单调栈的总结","text":"单调栈的总结 题目传送门：Gym-100971D Laying Cables题目大意：给定你一些城市（直线）的坐标和城市人口大小，要求你输出距离每个城市最近的比他人口大的城市标号，如果没有，则置为-1。 解题思路：维护一个单调递减的栈，分别从左到右，在从右到左，分别计算离他最近的点。 AC代码：1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3typedef long long ll;4const int maxn &#x3D; 200005;5struct Node6&#123;7 ll loc, v, num;8&#125;node[maxn];9bool cmp(Node x, Node y)10&#123;11 return x.loc &lt; y.loc;12&#125;13ll aim[maxn];14int main()15&#123;16 ll n, m, i, j, k, a, b;17 scanf(&quot;%lld&quot;, &amp;m);18 for(i &#x3D; 1; i &lt;&#x3D; m; i++)19 &#123;20 scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b);21 node[i].loc &#x3D; a;22 node[i].v &#x3D; b;23 node[i].num &#x3D; i;24 &#125;25 sort(node + 1, node + 1 + m, cmp);26 stack&lt;Node&gt;s;27 vector&lt;Node&gt;lef, rig;28 lef.resize(maxn);29 rig.resize(maxn);30 Node w;31 w.v &#x3D; w.loc &#x3D; 2e10;32 w.num &#x3D; -1;33 s.push(w);34 for(i &#x3D; 1; i &lt;&#x3D; m; i++)35 &#123;36 while(node[i].v &gt; s.top().v)s.pop();37 lef[i] &#x3D; s.top();38 s.push(node[i]);39 &#125;40 while(!s.empty())s.pop();41 node[m + 1].v &#x3D; 2e10;42 node[m + 1].loc &#x3D; 2e10;43 node[m + 1].num &#x3D; -1;44 s.push(node[m + 1]);45 for(i &#x3D; m; i &gt;&#x3D; 1; i--)46 &#123;47 while(node[i].v &gt; s.top().v)s.pop();48 rig[i] &#x3D; s.top();49 s.push(node[i]);50 &#125;51 for(i &#x3D; 1; i &lt;&#x3D; m; i++)52 &#123;53 if(abs(lef[i].loc - node[i].loc) &#x3D;&#x3D; abs(rig[i].loc - node[i].loc))54 &#123;55 if(lef[i].v &gt; rig[i].v)aim[node[i].num] &#x3D; lef[i].num;56 else aim[node[i].num] &#x3D; rig[i].num;57 &#125;58 else if(abs(lef[i].loc - node[i].loc) &gt; abs(rig[i].loc - node[i].loc))59 &#123;60 aim[node[i].num] &#x3D; rig[i].num;61 &#125;62 else aim[node[i].num] &#x3D; lef[i].num;63 &#125;64 for(i &#x3D; 1; i &lt;&#x3D; m; i++)65 &#123;66 if(i !&#x3D; 1)printf(&quot; &quot;);67 printf(&quot;%lld&quot;, aim[i]);68 &#125;69 printf(&quot;\\n&quot;);70 return 0;71&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"博弈","slug":"博弈","date":"2020-03-07T08:50:02.751Z","updated":"2020-03-07T08:51:01.705Z","comments":true,"path":"2020/03/07/博弈/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%8D%9A%E5%BC%88/","excerpt":"纳什博弈、威佐夫博弈、尼姆博弈的总结","text":"纳什博弈、威佐夫博弈、尼姆博弈的总结 HDU - 2516 取石子游戏 (斐波那契博弈)题目链接：https://cn.vjudge.net/contest/269106#problem/F 题目大意： 1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输出&quot;Second win&quot;.先取者胜输出&quot;First win&quot;.解题思路： 斐波那契博弈，n为斐波那契数时先手必败，用map记录一下斐波那契数即可。1#include &lt;bits/stdc++.h&gt;2using namespace std;3typedef long long ll;4map&lt;ll, ll&gt;mp;5int main()6&#123;7 ll i, n, a, b, c, len = 1e18;8 a = 1;9 b = 1;10 c = a + b;11 mp[1] = 1;12 while(c &lt;= len)13 &#123;14 mp[c] = 1;15 a = b;16 b = c;17 c = a + b;18 &#125;19 while(scanf(\"%lld\", &amp;n) != EOF)20 &#123;21 if(n == 0)break;22 if(mp[n] == 1)printf(\"Second win\\n\");23 else printf(\"First win\\n\");24 &#125;25 return 0;26&#125; HDU - 1527 取石子游戏 (威佐夫博弈)题目链接：https://cn.vjudge.net/contest/269106#problem/R 题目大意： 有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。解题思路： 威佐夫博弈，设（a，b），a &lt; b，若a / b最接近（sqrt（5） - 1）/ 2，则（a，b）为必败态。1#include &lt;bits/stdc++.h&gt;2using namespace std;3int main()4&#123;5 double a, b, c;6 while(scanf(\"%lf %lf\", &amp;a, &amp;b) != EOF)7 &#123;8 if(a &gt; b)&#123;c = a; a = b; b = c;&#125;9 c = (sqrt(5) - 1.0) / 2.0;10 if(abs((a + 1) / b - c) &gt; abs(a / b - c) &amp;&amp; abs((a - 1) / b - c) &gt; abs(a / b - c))11 &#123;12 printf(\"0\\n\");13 &#125;14 else printf(\"1\\n\");15 &#125;16 return 0;17&#125; HDU - 2176 取(m堆)石子游戏 （尼姆博弈）题目链接：https://cn.vjudge.net/contest/269106#problem/Q 题目大意： m堆石子,两人轮流取.只能在1堆中取.取完者胜.先取者负输出No.先取者胜输出Yes,然后输出怎样取子.例如5堆 5,7,8,9,10先取者胜,先取者第1次取时可以从有8个的那一堆取走7个剩下1个,也可以从有9个的中那一堆取走9个剩下0个,也可以从有10个的中那一堆取走7个剩下3个.解题思路： 尼姆博弈，即所有数异或和为0是必败态，否则为必胜态，首先异或一遍，为0输出No，不为零输出Yes，然后遍历石子数，sum ^= a[i]，则sum为除第i堆石子外的异或和，易知sum ^ sum = 0，故当sum &lt; a[i]时，第i堆石子可已走a[i] - sum个石子，使对手必败。1#include &lt;bits/stdc++.h&gt;2using namespace std;3typedef long long ll;4ll a[200005];5int main()6&#123;7 ll n, sum, i, left;8 while(scanf(\"%lld\", &amp;n) != EOF)9 &#123;10 if(n == 0)break;11 sum = 0;12 for(i = 1; i &lt;= n; i++)13 &#123;14 scanf(\"%lld\", &amp;a[i]);15 sum ^= a[i];16 &#125;17 if(sum == 0)18 &#123;19 printf(\"No\\n\");20 &#125;21 else22 &#123;23 printf(\"Yes\\n\");24 for(i = 1; i &lt;= n; i++)25 &#123;26 sum ^= a[i];27 left = sum;28 if(left &lt;= a[i])29 &#123;30 printf(\"%lld %lld\\n\", a[i], left);31 &#125;32 sum ^= a[i];33 &#125;34 &#125;35 &#125;36 return 0;37&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"背包问题","slug":"背包问题","date":"2020-03-07T08:47:50.595Z","updated":"2020-03-07T08:49:45.718Z","comments":true,"path":"2020/03/07/背包问题/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"01背包、完全背包、多重背包的总结","text":"01背包、完全背包、多重背包的总结 动态规划—简单背包问题 零 开始之前 什么是动态规划？ 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法叫做动态规划。 什么时候能用动态规划？ 动态规划常常适用于有重叠子问题和最优子结构性质的问题。 什么是最优子结构？ 当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。 什么是重叠子问题？ 在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。 动态规划该怎么做？ 1、确定状态 2、确定状态转移方程 3、从大到小（记忆化+递归）、从小到大（递推） 一个简单的例子 爬楼梯问题 你正在爬一个有n个台阶的楼梯，每次只能上1个或者2个台阶，那么到达顶端共有多少种不同的方法？ 确定状态 dp[i] 表示有 i 个台阶时的方法数 确定转移方程 dp[i] = dp[i - 1] + dp[i - 2]。 递归加记忆化求解： #include &lt;bits/stdc++.h&gt; #define ll long long #define N 5123 using namespace std; int dp[N]; int F(int n){ if(n == 1 || n == 2)return n; //边界 if(dp[n] != 0)return dp[n]; //记忆化 return F(n - 1) + F(n - 2); // 转移 } int main(){ int n; scanf(“%d”, &amp;n); printf(“%d\\n”, F(n)); } 递推求解： #include &lt;bits/stdc++.h&gt; #define ll long long #define N 5123 using namespace std; int dp[N]; int main(){ int n; scanf(“%d”, &amp;n); dp[1] = 1; dp[2] = 2; //边界 for(int i = 3; i &lt;= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; //转移 printf(“%d\\n”, dp[n]); } 什么是背包问题？ 动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。背包问题是动态规划问题的一种类型。 一 0-1背包问题 简化的 01-背包 ——装箱问题 题目链接：（https://www.acwing.com/problem/content/1026/） 题目大意：有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积（正整数）。 要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。 确定状态 dp[i][j] 表示前 i 个物品能否组成体积 j 确定转移方程 dp[i][j] = 1 (f[i - 1][j] == 1 || f[i - 1][j - v[i]] == 1) dp[i][j] = 0 (else) 列表验证 样例输入: 24 6 ​ 8 3 12 7 9 7 样例输出：0 递推解决 #include &lt;bits/stdc++.h&gt; #define ll long long #define N 21234 using namespace std; int dp[31][N], a[31]; int main() { int v, n; scanf(“%d %d”, &amp;v, &amp;n); for(int i = 1; i &lt;= n; i++)scanf(“%d”, &amp;a[i]); dp[0][0] = 1; int ans = v; for(int i = 1; i &lt;= n; i++){ for(int j = 0; j &lt;= v; j++){ if(dp[i - 1][j] == 1)dp[i][j] = 1; if(j - a[i] &gt;= 0 &amp;&amp; dp[i - 1][j - a[i]] == 1)dp[i][j] = 1; if(dp[i][j] == 1)ans = min(ans, v - j); } } printf(“%d\\n”, ans); } 01滚动 我们可以看到每一行的结果实际上只与上一行有关，所以就可以01滚动——f[i][0,1] 一行记录前一行的值，另一行记录当前行的值…… 就地滚动 对于本题更加常用的方法是就地滚动，顾名思义只用一个一维数组了!之前的状态和当前的状态都记在同一个数组里了！ 比如： for(int i = 1; i &lt;= n; i++){ for(int j = 0; j &lt;= v; j++){ if([j] == 1)dp[j] = 1; if(j - a[i] &gt;= 0 &amp;&amp; dp[j - a[i]] == 1)dp[j] = 1; } } 但是简单的变成一维以后有可能发出问题 比如： 假设第一个物品体积3 一个物品被使用了多次！ 如何解决？ 我们只需改变内层循环的顺序即可！ for(int i = 1; i &lt;= n; i++){ for(int j = v; j &gt;= 0; j–){ if([j] == 1)dp[j] = 1; if(j - a[i] &gt;= 0 &amp;&amp; dp[j - a[i]] == 1)dp[j] = 1; } } 问题得到解决！ 0-1背包问题 题目链接：（https://www.acwing.com/problem/content/2/） 题目大意：有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 确定状态 f[i][j]表示前i件物品恰放入一个容量为j的背包可以获得的最大价值 确定状态转移方程 两种情况： 1.不放当前物品 f[i][j] = f[i-1][j] 2.放当前物品 f[i][j] = f[i-1][j-c[i]]+w[i] f[i][j]=max{f[i-1][j],f[i-1][j-c[i]]+w[i]} 列表验证 就地滚动 #include &lt;bits/stdc++.h&gt; using namespace std; #define N 2123 #define ll long long int dp[N], u[N], v[N]; int main() { ios::sync_with_stdio(0); int n, w, ans = 0; cin &gt;&gt; n &gt;&gt; w; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; u[i] &gt;&gt; v[i]; } for(int i = 1; i &lt;= n; i++){ for(int j = w; j &gt;= u[i]; j–){ dp[j] = max(dp[j], dp[j - u[i]] + v[i]); ans = max(ans, dp[j]); } } printf(“%d\\n”, ans); return 0; } 二 完全背包问题 题目链接：（https://www.acwing.com/problem/content/3/） 题目大意：有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 Ci ，价值是 Wi 。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。 回忆 0-1 背包的就地滚动 回想 0-1 背包就地滚动时错误的代码，之所以错误，是因为每件物品重复使用多次，这恰好符合本题的要求！ 递推求解 #include &lt;bits/stdc++.h&gt; using namespace std; #define N 2123 #define ll long long int dp[N], u[N], v[N]; int main() { ios::sync_with_stdio(0); int n, w, ans = 0; cin &gt;&gt; n &gt;&gt; w; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; u[i] &gt;&gt; v[i]; } for(int i = 1; i &lt;= n; i++){ for(int j = u[i]; j &lt;= w; j++){ dp[j] = max(dp[j], dp[j - u[i]] + v[i]); ans = max(ans, dp[j]); } } printf(“%d\\n”, ans); return 0; } 三 多重背包 题目链接：（https://www.acwing.com/problem/content/3/） 题目大意：有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 问题的转化 对于本题，我们可以将其拆解为 0-1 背包问题解决 如何优化 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int N,V,v[1001],w[1001],dp[2001],s[1001] int a[25000],b[25000]; //2的12次方大于2000，也就是说一个数最多可以拆成12个，故数组容量乘12 cin&gt;&gt;N&gt;&gt;V; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;N;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i]; int total=0; for(int i=0;i&lt;N;i++) { for(int j=1;j&lt;s[i];j&lt;&lt;=1)//二进制拆分 { a[total]=jw[i];//存价值 b[total++]=jv[i];//存容量 s[i]-=j; } if(s[i])//当s[i]&gt;0; { a[total]=s[i]w[i]; b[total++]=s[i]v[i]; } } for(int i=0;i&lt;total;i++)//01背包 for(int j=V;j&gt;=b[i];j–) dp[j]=max(dp[j],dp[j-b[i]]+a[i]); cout&lt;&lt;dp[V]; return 0; } 四 参考资料 博客：动态规划快速入门：https://www.jianshu.com/p/4dd4717301dc 题目：AcWing题库 参考课件：背包九讲（崔添翼） ​ nwpu2014暑假集训：动态规划2——简单背包问题（dsy）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}]}